if ( TRACE ) { TRACE( JSON.parse( '["AudioLibrary#init","AudioLibrary#Initialize","AudioLibrary#TryGetClip","AudioLibrary.ClipEntry#getDefaultValue","AudioLibrary.ClipEntry#ctor","AudioLibrary.ClipEntry#getHashCode","AudioLibrary.ClipEntry#equals","AudioLibrary.ClipEntry#$clone","ButtonPulse#init","ButtonPulse#Awake","ButtonPulse#OnEnable","ButtonPulse#OnDisable","ButtonPulse#StartPulse","ButtonPulse#StopPulse","Core.Services.ServicesLocator#init","Core.Services.ServicesLocator#Register","Core.Services.ServicesLocator#Get","Core.Services.ServicesLocator#Unregister","Core.Services.ServicesLocator#ClearAll","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOFade$4","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOColor$3","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOScale","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOCounter","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI#DOShapeCircle","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","FluidGridLayout#init","FluidGridLayout#CalculateLayoutInputHorizontal","FluidGridLayout#CalculateLayoutInputVertical","FluidGridLayout#SetLayoutHorizontal","FluidGridLayout#SetLayoutVertical","FluidGridLayout#ComputeLayout","FluidGridLayout#ApplyChildrenLayout","FluidGridLayout#GetActiveChildCount","FluidGridLayout#OnRectTransformDimensionsChange","FluidGridLayout#OnEnable","FluidGridLayout#OnTransformChildrenChanged","FluidGridLayout#SetDirty$1","GameManager#CurrentScore#get","GameManager#CurrentScore#set","GameManager#Awake","GameManager#Start","GameManager#Win","GameManager#DestroyHandObj","GameManager#CTAClicked","GameManager#ChangeState","GameManager#RestartGame","GameManager#StartMusic","HorizontalUIDragClamp#init","HorizontalUIDragClamp#Awake","HorizontalUIDragClamp#Update","HorizontalUIDragClamp#OnBeginDrag","HorizontalUIDragClamp#OnDrag","HorizontalUIDragClamp#OnEndDrag","HorizontalUIDragClamp#IsDragValid","HorizontalUIDragClamp#ClampWithinParentHorizontal","OrientationLayoutSwitcher#init","OrientationLayoutSwitcher#OnEnable","OrientationLayoutSwitcher#OnDisable","OrientationLayoutSwitcher#Handle","OrientationLayoutSwitcher#ApplySafe","ResponsiveUIManager#init","ResponsiveUIManager#Reset","ResponsiveUIManager#OnEnable","ResponsiveUIManager#OnDisable","ResponsiveUIManager#Update","ResponsiveUIManager#ApplyFrame","ResponsiveUIManager#TryCache","ResponsiveUIManager#DetectOrientation","ResponsiveUIManager#ApplyOrientation","ResponsiveUIManager#ApplyAll","ResponsiveUIManager#TrySetDynamicPixelsPerUnit","ResponsiveUIManager#ChooseMatchByAspect","ResponsiveUIManager#AdjustForOrientation","ResponsiveUIManager#ApplySafeArea","ResponsiveUIManager#ApplyStrictAspect","ResponsiveUIManager#StripDecorativeRaycasts","ResponsiveUIManager#ForceAspectProfile","ResponsiveUIManager#ClearAspectProfileOverride","ResponsiveUIManager.AspectProfile#getDefaultValue","ResponsiveUIManager.AspectProfile#ctor","ResponsiveUIManager.AspectProfile#getHashCode","ResponsiveUIManager.AspectProfile#equals","ResponsiveUIManager.AspectProfile#$clone","ResponsiveUIManager.StrictAspectEntry#getDefaultValue","ResponsiveUIManager.StrictAspectEntry#ctor","ResponsiveUIManager.StrictAspectEntry#getHashCode","ResponsiveUIManager.StrictAspectEntry#equals","ResponsiveUIManager.StrictAspectEntry#$clone","StartClickHandler#Start","StartClickHandler#Update","StartClickHandler#OnPointerDown","StartClickHandler#EnableSound","TaskManager#init","TaskManager#Awake","TaskManager#CreateSequence","TaskManager#CreatePooledSequence","TaskManager#Run","TaskManager#RunTask","TaskManager#StopTask","TaskManager#StopAllTasks","TaskManager#RunAfter","TaskManager#RunAfter$1","TaskManager#RunUntil","TaskManager#RunWhile","TaskManager#RunRepeating","TaskManager#DelayRoutine","TaskManager#RunAfterRoutine","TaskManager#WaitUntilRoutine","TaskManager#WhileRoutine","TaskManager#RepeatingRoutine","TaskSequencePool#init","TaskSequencePool#init","TaskSequencePool#ctor","TaskSequencePool#Get","TaskSequencePool#Return","TaskSequencePro#CoroutineHost#get","TaskSequencePro#IsRunning#get","TaskSequencePro#IsPaused#get","TaskSequencePro#IsCancelled#get","TaskSequencePro#IsCompleted#get","TaskSequencePro#HasStarted#get","TaskSequencePro#init","TaskSequencePro#ctor","TaskSequencePro#Append","TaskSequencePro#AppendDelayRealtime","TaskSequencePro#DelayRealtimeRoutine","TaskSequencePro#AppendWaitForFixedUpdate","TaskSequencePro#WaitForFixedUpdateRoutine","TaskSequencePro#AppendWaitForEndOfFrame","TaskSequencePro#WaitForEndOfFrameRoutine","TaskSequencePro#AppendCallback","TaskSequencePro#AppendDelay","TaskSequencePro#AppendWaitUntil","TaskSequencePro#AppendWaitWhile","TaskSequencePro#AppendRoutine","TaskSequencePro#AppendTween","TaskSequencePro#AppendParallel$1","TaskSequencePro#AppendParallel","TaskSequencePro#AppendParallelTweens","TaskSequencePro#AppendRepeat","TaskSequencePro#AppendCondition","TaskSequencePro#AppendIf","TaskSequencePro#AppendDelayIf","TaskSequencePro#AppendTweenIf","TaskSequencePro#OnComplete","TaskSequencePro#OnCancel","TaskSequencePro#Start","TaskSequencePro#Cancel","TaskSequencePro#Pause","TaskSequencePro#Resume","TaskSequencePro#Restart","TaskSequencePro#Reset","TaskSequencePro#RunSequence","TaskSequencePro#HandleComplete","TaskSequencePro#ReturnToPoolIfNeeded","TaskSequencePro#ActionRoutine","TaskSequencePro#DelayRoutine","TaskSequencePro#WaitUntilRoutine","TaskSequencePro#WaitWhileRoutine","TaskSequencePro#WaitForTween","TaskSequencePro#RunParallelRoutines","TaskSequencePro#RunAndTrack","TaskSequencePro#RepeatRoutine","UIDragger#init","UIDragger#Awake","UIDragger#OnBeginDrag","UIDragger#OnDrag","UIDragger#OnEndDrag","AudioManager#init","AudioManager#Awake","AudioManager#OnDisable","AudioManager#PlaySFX","AudioManager#PlayMusic","AudioManager#StopMusic$1","AudioManager#StopMusic","AudioManager#SetMusicVolume","AudioManager#SetSFXVolume","AudioManager#ReturnToPoolWhenDone","AudioManager#CrossfadeMusic","AudioManager#FadeOutAndStop"]' ) ); }
/**
 * @version 1.0.9399.29152
 * @copyright anton
 * @compiler Bridge.NET 17.9.42-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*AudioChannel start.*/
    Bridge.define("AudioChannel", {
        $kind: 6,
        statics: {
            fields: {
                Music: 0,
                SFX: 1
            }
        }
    });
    /*AudioChannel end.*/

    /*AudioLibrary start.*/
    Bridge.define("AudioLibrary", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            clips: null,
            lookup: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AudioLibrary#init", this ); }

                this.clips = new (System.Collections.Generic.List$1(AudioLibrary.ClipEntry)).ctor();
            }
        },
        methods: {
            /*AudioLibrary.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "AudioLibrary#Initialize", this ); }

                var $t;
                this.lookup = new (System.Collections.Generic.Dictionary$2(System.String,AudioLibrary.ClipEntry)).ctor();
                $t = Bridge.getEnumerator(this.clips);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current.$clone();
                        if (!this.lookup.containsKey(entry.key)) {
                            this.lookup.add(entry.key, entry.$clone());
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*AudioLibrary.Initialize end.*/

            /*AudioLibrary.TryGetClip start.*/
            TryGetClip: function (key, entry) {
if ( TRACE ) { TRACE( "AudioLibrary#TryGetClip", this ); }

                if (this.lookup == null) {
                    this.Initialize();
                }
                return this.lookup.tryGetValue(key, entry);
            },
            /*AudioLibrary.TryGetClip end.*/


        }
    });
    /*AudioLibrary end.*/

    /*AudioLibrary+ClipEntry start.*/
    Bridge.define("AudioLibrary.ClipEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "AudioLibrary.ClipEntry#getDefaultValue", this ); }
 return new AudioLibrary.ClipEntry(); }
            }
        },
        fields: {
            key: null,
            channel: 0,
            clip: null,
            volume: 0,
            loop: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "AudioLibrary.ClipEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "AudioLibrary.ClipEntry#getHashCode", this ); }

                var h = Bridge.addHash([3806190337, this.key, this.channel, this.clip, this.volume, this.loop]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "AudioLibrary.ClipEntry#equals", this ); }

                if (!Bridge.is(o, AudioLibrary.ClipEntry)) {
                    return false;
                }
                return Bridge.equals(this.key, o.key) && Bridge.equals(this.channel, o.channel) && Bridge.equals(this.clip, o.clip) && Bridge.equals(this.volume, o.volume) && Bridge.equals(this.loop, o.loop);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "AudioLibrary.ClipEntry#$clone", this ); }

                var s = to || new AudioLibrary.ClipEntry();
                s.key = this.key;
                s.channel = this.channel;
                s.clip = this.clip;
                s.volume = this.volume;
                s.loop = this.loop;
                return s;
            }
        }
    });
    /*AudioLibrary+ClipEntry end.*/

    /*Core.Services.IAudioService start.*/
    Bridge.define("Core.Services.IAudioService", {
        $kind: 3
    });
    /*Core.Services.IAudioService end.*/

    /*ButtonPulse start.*/
    Bridge.define("ButtonPulse", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            scaleMultiplier: 0,
            pulseDuration: 0,
            _originalScale: null,
            _pulseTween: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ButtonPulse#init", this ); }

                this._originalScale = new UnityEngine.Vector3();
            }
        },
        methods: {
            /*ButtonPulse.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ButtonPulse#Awake", this ); }

                this._originalScale = this.transform.localScale.$clone();
            },
            /*ButtonPulse.Awake end.*/

            /*ButtonPulse.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "ButtonPulse#OnEnable", this ); }

                this.StartPulse();
            },
            /*ButtonPulse.OnEnable end.*/

            /*ButtonPulse.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "ButtonPulse#OnDisable", this ); }

                this.StopPulse(true);
            },
            /*ButtonPulse.OnDisable end.*/

            /*ButtonPulse.StartPulse start.*/
            StartPulse: function () {
if ( TRACE ) { TRACE( "ButtonPulse#StartPulse", this ); }

                // Kill any running tween before starting
                this._pulseTween != null ? DG.Tweening.TweenExtensions.Kill(this._pulseTween) : null;

                var targetScale = this._originalScale.$clone().clone().scale( this.scaleMultiplier );

                this._pulseTween = DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.transform, targetScale.$clone(), this.pulseDuration), DG.Tweening.Ease.InOutSine), -1, DG.Tweening.LoopType.Yoyo);
            },
            /*ButtonPulse.StartPulse end.*/

            /*ButtonPulse.StopPulse start.*/
            StopPulse: function (resetScale) {
if ( TRACE ) { TRACE( "ButtonPulse#StopPulse", this ); }

                if (resetScale === void 0) { resetScale = false; }
                if (this._pulseTween != null && DG.Tweening.TweenExtensions.IsActive(this._pulseTween)) {
                    DG.Tweening.TweenExtensions.Kill(this._pulseTween);
                }

                if (resetScale) {
                    this.transform.localScale = this._originalScale.$clone();
                }
            },
            /*ButtonPulse.StopPulse end.*/


        }
    });
    /*ButtonPulse end.*/

    /*Core.Services.ServicesLocator start.*/
    Bridge.define("Core.Services.ServicesLocator", {
        statics: {
            fields: {
                _services: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Core.Services.ServicesLocator#init", this ); }

                    this._services = new (System.Collections.Generic.Dictionary$2(System.Type,System.Object)).ctor();
                }
            },
            methods: {
                /*Core.Services.ServicesLocator.Register:static start.*/
                /**
                 * Registers a service instance
                 *
                 * @static
                 * @public
                 * @this Core.Services.ServicesLocator
                 * @memberof Core.Services.ServicesLocator
                 * @param   {Function}    T          
                 * @param   {T}           service
                 * @return  {void}
                 */
                Register: function (T, service) {
if ( TRACE ) { TRACE( "Core.Services.ServicesLocator#Register", this ); }

                    var type = T;
                    if (Core.Services.ServicesLocator._services.containsKey(type)) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Service of type {0} is already registered. Replacing.", [type]));
                    }
                    Core.Services.ServicesLocator._services.setItem(type, Bridge.rValue(service));
                },
                /*Core.Services.ServicesLocator.Register:static end.*/

                /*Core.Services.ServicesLocator.Get:static start.*/
                /**
                 * Get Registered service. Throw if not found
                 *
                 * @static
                 * @public
                 * @this Core.Services.ServicesLocator
                 * @memberof Core.Services.ServicesLocator
                 * @throws 
                 * @param   {Function}    T
                 * @return  {T}
                 */
                Get: function (T) {
if ( TRACE ) { TRACE( "Core.Services.ServicesLocator#Get", this ); }

                    var type = T;
                    var service = { };
                    if (Core.Services.ServicesLocator._services.tryGetValue(type, service)) {
                        return Bridge.as(service.v, T);
                    }

                    throw new System.Exception(System.String.format("Service of {0} is not registered", [type]));
                },
                /*Core.Services.ServicesLocator.Get:static end.*/

                /*Core.Services.ServicesLocator.Unregister:static start.*/
                /**
                 * Removes a registered service
                 *
                 * @static
                 * @public
                 * @this Core.Services.ServicesLocator
                 * @memberof Core.Services.ServicesLocator
                 * @param   {Function}    T
                 * @return  {void}
                 */
                Unregister: function (T) {
if ( TRACE ) { TRACE( "Core.Services.ServicesLocator#Unregister", this ); }

                    var type = T;
                    Core.Services.ServicesLocator._services.remove(type);
                },
                /*Core.Services.ServicesLocator.Unregister:static end.*/

                /*Core.Services.ServicesLocator.ClearAll:static start.*/
                /**
                 * Clear all registered service(for cleanup or scene transitions).
                 *
                 * @static
                 * @public
                 * @this Core.Services.ServicesLocator
                 * @memberof Core.Services.ServicesLocator
                 * @return  {void}
                 */
                ClearAll: function () {
if ( TRACE ) { TRACE( "Core.Services.ServicesLocator#ClearAll", this ); }

                    Core.Services.ServicesLocator._services.clear();
                },
                /*Core.Services.ServicesLocator.ClearAll:static end.*/


            }
        }
    });
    /*Core.Services.ServicesLocator end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {pc.ColorGradient}              gradient    The gradient to use
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Color}             endValue    The value to tween to
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                /**
                 * Tweens a CanvasGroup's alpha color to the given value.
                 Also stores the canvasGroup as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.CanvasGroup}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                /**
                 * Tweens an Graphic's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                /**
                 * Tweens an Image's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                /**
                 * Tweens a Outline's effectColor alpha to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static start.*/
                /**
                 * Tweens a Text's alpha color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$4: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$4", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$4:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                /**
                 * Tweens an Graphic's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                /**
                 * Tweens an Image's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                /**
                 * Tweens a Outline's effectColor to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.effectColor;
                    }, function (x) {
                        target.effectColor = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static start.*/
                /**
                 * Tweens a Text's color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$3", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                /**
                 * Tweens an Image's fillAmount to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1) {
                        endValue = 1;
                    } else {
                        if (endValue < 0) {
                            endValue = 0;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                /**
                 * Tweens an Image's colors using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                /**
                 * Tweens an LayoutElement's flexibleWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                /**
                 * Tweens an LayoutElement's minWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                /**
                 * Tweens an LayoutElement's preferredWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOScale:static start.*/
                /**
                 * Tweens a Outline's effectDistance to the given value.
                 Also stores the Outline as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Outline}            target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOScale: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOScale", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.effectDistance;
                    }, function (x) {
                        target.effectDistance = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOScale:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Z to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                /**
                 * Tweens a RectTransform's anchorMax to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                /**
                 * Tweens a RectTransform's anchorMin to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                /**
                 * Tweens a RectTransform's pivot to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                /**
                 * Tweens a RectTransform's pivot X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                /**
                 * Tweens a RectTransform's pivot Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                /**
                 * Tweens a RectTransform's sizeDelta to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                /**
                 * Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
                 as if it was connected to the starting position via an elastic.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {UnityEngine.Vector2}          punch         The direction and strength of the punch (added to the RectTransform's current position)
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                       elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                 1 creates a full oscillation between the punch direction and the opposite direction,
                 while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {number}                             strength          The shake strength
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}          target            
                 * @param   {number}                             duration          The duration of the tween
                 * @param   {UnityEngine.Vector2}                strength          The shake strength on each axis
                 * @param   {number}                             vibrato           Indicates how much will the shake vibrate
                 * @param   {number}                             randomness        Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                            snapping          If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                            fadeOut           If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @param   {DG.Tweening.ShakeRandomnessMode}    randomnessMode    Randomness mode
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut, randomnessMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    if (randomnessMode === void 0) { randomnessMode = 0; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut, randomnessMode), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target       
                 * @param   {UnityEngine.Vector2}          endValue     The end value to reach
                 * @param   {number}                       jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                       numJumps     Total number of jumps
                 * @param   {number}                       duration     The duration of the tween
                 * @param   {boolean}                      snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.anchoredPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = pos.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {UnityEngine.Vector2}          endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                /**
                 * Tweens a Slider's value to the given value.
                 Also stores the Slider as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Slider}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOCounter:static start.*/
                /**
                 * Tweens a Text's text from one integer to another, with options for thousands separators
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}                 target                   
                 * @param   {number}                              fromValue                The value to start from
                 * @param   {number}                              endValue                 The end value to reach
                 * @param   {number}                              duration                 The duration of the tween
                 * @param   {boolean}                             addThousandsSeparator    If TRUE (default) also adds thousands separators
                 * @param   {System.Globalization.CultureInfo}    culture                  The {@link } to use (InvariantCulture if NULL)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOCounter: function (target, fromValue, endValue, duration, addThousandsSeparator, culture) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOCounter", this ); }

                    if (addThousandsSeparator === void 0) { addThousandsSeparator = true; }
                    if (culture === void 0) { culture = null; }
                    var v = fromValue;
                    var cInfo = !addThousandsSeparator ? null : culture || System.Globalization.CultureInfo.invariantCulture;
                    var t = DG.Tweening.DOTween.To$2(function () {
                        return v;
                    }, function (x) {
                        v = x;
                        target.text = addThousandsSeparator ? System.Int32.format(v, "N0", cInfo) : Bridge.toString(v);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOCounter:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                /**
                 * Tweens a Text's text to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target             
                 * @param   {string}                            endValue           The end string to tween to
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           richTextEnabled    If TRUE (default), rich text will be interpreted correctly while animated,
                 otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble mode to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                 Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
                 Leave it to NULL (default) to use default ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (endValue == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                        }
                        endValue = "";
                    }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                /**
                 * Tweens a Graphic's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Graphic as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}    target      
                 * @param   {UnityEngine.Color}         endValue    The value to tween to
                 * @param   {number}                    duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Image's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Text's color BY the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}    target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition so that it draws a circle around the given center.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations.<p />
                 IMPORTANT: SetFrom(value) requires a {@link } instead of a float, where the X property represents the "from degrees value"
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target             
                 * @param   {UnityEngine.Vector2}               center             Circle-center/pivot around which to rotate (in UI anchoredPosition coordinates)
                 * @param   {number}                            endValueDegrees    The end value degrees to reach (to rotate counter-clockwise pass a negative value)
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           relativeCenter     If TRUE the {@link } coordinates will be considered as relative to the target's current anchoredPosition
                 * @param   {boolean}                           snapping           If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOShapeCircle: function (target, center, endValueDegrees, duration, relativeCenter, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShapeCircle", this ); }

                    if (relativeCenter === void 0) { relativeCenter = false; }
                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To(UnityEngine.Vector2, UnityEngine.Vector2, DG.Tweening.Plugins.CircleOptions, DG.Tweening.Plugins.CirclePlugin.Get(), function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, center.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$7(t, endValueDegrees, relativeCenter, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOShapeCircle:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                /**
                 * Converts the anchoredPosition of the first RectTransform to the second RectTransform,
                 taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI.Utils
                 * @memberof DG.Tweening.DOTweenModuleUI.Utils
                 * @param   {UnityEngine.RectTransform}    from    
                 * @param   {UnityEngine.RectTransform}    to
                 * @return  {UnityEngine.Vector2}
                 */
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var localPoint = { v : new UnityEngine.Vector2() };
                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position);
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    /** @namespace DG.Tweening */

    /**
     * Shortcuts/functions that are not strictly related to specific Modules
     but are available only on some Unity versions
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUnityVersion
     */
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                /**
                 * Tweens a Material's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                /**
                 * Tweens a Material's named color property using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.SetColor$1(property, c.color);
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or complete.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion(true);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or rewinded.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has gone through the given amount of loops.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                elapsedLoops                    Elapsed loops to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed
                 or has reached the given time position (loops included, delays excluded).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                position                        Position (loops included, delays excluded) to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or started
                 (meaning when the tween is set in a playing state the first time, after any eventual delay).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                /**
                 * Tweens a Material's named texture offset property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                /**
                 * Tweens a Material's named texture scale property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    /**
     * Utility functions that deal with available Modules.
     Modules defines:
     - DOTAUDIO
     - DOTPHYSICS
     - DOTPHYSICS2D
     - DOTSPRITE
     - DOTUI
     Extra defines set and used for implementation of external assets:
     - DOTWEEN_TMP  TextMesh Pro
     - DOTWEEN_TK2D  2D Toolkit
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUtils
     */
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                /**
                 * Called via Reflection by DOTweenComponent on Awake
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUtils
                 * @memberof DG.Tweening.DOTweenModuleUtils
                 * @return  {void}
                 */
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (DG.Tweening.DOTweenModuleUtils._initialized) {
                        return;
                    }

                    DG.Tweening.DOTweenModuleUtils._initialized = true;
                    DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);

                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    trans.rotation = newRot.$clone();
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return false;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return false;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t = null;
                    var rBodyFoundAndTweened = false;
                    if (!rBodyFoundAndTweened) {
                        t = isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode);
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*FluidGridLayout start.*/
    /**
     * Production-grade fluid grid for Unity UI:
     - Best-fit columns/rows OR fixed constraints
     - Alignment: Start/Center/End/Justify per axis (+ centerX/centerY toggles)
     - Order: RowMajor/ColumnMajor, LTR/RTL, TTB/BTB, optional reverse
     - Cell sizing: keep square, fixed aspect, min/max clamps
     - Overflow modes: ClampToParent, AllowVerticalScroll, ScaleDownToFit
     - Pixel snapping, optional child resizing, auto rebuild on child changes
     - ScrollRect friendly
     *
     * @public
     * @class FluidGridLayout
     * @augments UnityEngine.UI.LayoutGroup
     */
    Bridge.define("FluidGridLayout", {
        inherits: [UnityEngine.UI.LayoutGroup],
        fields: {
            fitAxis: 0,
            overflow: 0,
            constraint: 0,
            constraintCount: 0,
            columnsRange: null,
            evenness: 0,
            keepSquare: false,
            enforceAspect: false,
            aspectWH: 0,
            minCell: null,
            maxCell: null,
            spacing: null,
            horizontalAlign: 0,
            verticalAlign: 0,
            centerX: false,
            centerY: false,
            order: 0,
            horizontalDirection: 0,
            verticalDirection: 0,
            reverseOrder: false,
            overrideChildSize: false,
            snapToPixels: false,
            autoRebuildOnChildChange: false,
            respectMinCellOnScaleDown: false,
            preserveAspectOnScaleDown: false,
            _chosenColumns: 0,
            _chosenRows: 0,
            _chosenCell: null
        },
        alias: [
            "CalculateLayoutInputHorizontal", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputHorizontal",
            "CalculateLayoutInputVertical", "UnityEngine$UI$ILayoutElement$CalculateLayoutInputVertical",
            "SetLayoutHorizontal", "UnityEngine$UI$ILayoutController$SetLayoutHorizontal",
            "SetLayoutVertical", "UnityEngine$UI$ILayoutController$SetLayoutVertical"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#init", this ); }

                this.columnsRange = new UnityEngine.Vector2Int();
                this.minCell = new UnityEngine.Vector2();
                this.maxCell = new UnityEngine.Vector2();
                this.spacing = new UnityEngine.Vector2();
                this._chosenCell = new UnityEngine.Vector2();
                this.fitAxis = FluidGridLayout.FitAxis.Both;
                this.overflow = FluidGridLayout.OverflowMode.ClampToParent;
                this.constraint = FluidGridLayout.Constraint.None;
                this.constraintCount = 3;
                this.columnsRange = new UnityEngine.Vector2Int.$ctor1(1, 12);
                this.evenness = 0;
                this.keepSquare = false;
                this.enforceAspect = false;
                this.aspectWH = 1.0;
                this.minCell = new pc.Vec2( 80, 80 );
                this.maxCell = new pc.Vec2( 4096, 4096 );
                this.spacing = new pc.Vec2( 8, 8 );
                this.horizontalAlign = FluidGridLayout.HAlign.Start;
                this.verticalAlign = FluidGridLayout.VAlign.Start;
                this.centerX = false;
                this.centerY = false;
                this.order = FluidGridLayout.OrderMode.RowMajor;
                this.horizontalDirection = FluidGridLayout.HorizontalDir.LeftToRight;
                this.verticalDirection = FluidGridLayout.VerticalDir.TopToBottom;
                this.reverseOrder = false;
                this.overrideChildSize = true;
                this.snapToPixels = true;
                this.autoRebuildOnChildChange = true;
                this.respectMinCellOnScaleDown = false;
                this.preserveAspectOnScaleDown = true;
            }
        },
        methods: {
            /*FluidGridLayout.CalculateLayoutInputHorizontal start.*/
            CalculateLayoutInputHorizontal: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#CalculateLayoutInputHorizontal", this ); }

                UnityEngine.UI.LayoutGroup.prototype.CalculateLayoutInputHorizontal.call(this);
                this.ComputeLayout();
                var prefW = this.padding.horizontal + this._chosenColumns * this._chosenCell.x + this.spacing.x * UnityEngine.Mathf.Max(0, ((this._chosenColumns - 1) | 0));
                this.SetLayoutInputForAxis(prefW, prefW, -1, 0);
            },
            /*FluidGridLayout.CalculateLayoutInputHorizontal end.*/

            /*FluidGridLayout.CalculateLayoutInputVertical start.*/
            CalculateLayoutInputVertical: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#CalculateLayoutInputVertical", this ); }

                var prefH = this.padding.vertical + this._chosenRows * this._chosenCell.y + this.spacing.y * UnityEngine.Mathf.Max(0, ((this._chosenRows - 1) | 0));
                this.SetLayoutInputForAxis(prefH, prefH, -1, 1);
            },
            /*FluidGridLayout.CalculateLayoutInputVertical end.*/

            /*FluidGridLayout.SetLayoutHorizontal start.*/
            SetLayoutHorizontal: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#SetLayoutHorizontal", this ); }

                this.ApplyChildrenLayout();
            },
            /*FluidGridLayout.SetLayoutHorizontal end.*/

            /*FluidGridLayout.SetLayoutVertical start.*/
            SetLayoutVertical: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#SetLayoutVertical", this ); }

                this.ApplyChildrenLayout();
            },
            /*FluidGridLayout.SetLayoutVertical end.*/

            /*FluidGridLayout.ComputeLayout start.*/
            ComputeLayout: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#ComputeLayout", this ); }

                var Consider = null;
                var rect = this.rectTransform.rect.$clone();
                var parentW = UnityEngine.Mathf.Max(0, rect.width - this.padding.horizontal);
                var parentH = UnityEngine.Mathf.Max(0, rect.height - this.padding.vertical);

                var childCount = this.GetActiveChildCount();
                if (childCount === 0 || parentW <= 1 || parentH <= 1) {
                    this._chosenColumns = 0;
                    this._chosenRows = 0;
                    this._chosenCell = pc.Vec2.ZERO.clone();
                    return;
                }

                var minCols = UnityEngine.Mathf.Max(1, this.columnsRange.x);
                var maxCols = UnityEngine.Mathf.Max(minCols, this.columnsRange.y);

                var bestScore = Number.NEGATIVE_INFINITY;
                var bestCols = 1;
                var bestRows = childCount;
                var bestCell = pc.Vec2.ZERO.clone();


                Consider = Bridge.fn.bind(this, function (cols) {
                    if (cols < 1) {
                        cols = 1;
                    }
                    if (this.evenness > 0 && (cols % this.evenness) !== 0) {
                        return;
                    }
                    var rows = Math.ceil(childCount / cols);
                    // Candidate cell sizes from width/height fits
                    var totalSpacingX = this.spacing.x * UnityEngine.Mathf.Max(0, ((cols - 1) | 0));
                    var cw = (parentW - totalSpacingX) / cols;
                    var ch;
                    if (this.overflow === FluidGridLayout.OverflowMode.AllowVerticalScroll) {
                        // Fit width; vertical can scroll or be derived
                        if (this.keepSquare) {
                            ch = cw;
                        } else {
                            if (this.enforceAspect) {
                                ch = cw / UnityEngine.Mathf.Max(0.01, this.aspectWH);
                            } else {
                                var totalSpacingY = this.spacing.y * UnityEngine.Mathf.Max(0, ((rows - 1) | 0));
                                ch = (parentH - totalSpacingY) / UnityEngine.Mathf.Max(1, rows);
                            }
                        }
                    } else {
                        var totalSpacingY1 = this.spacing.y * UnityEngine.Mathf.Max(0, ((rows - 1) | 0));
                        ch = (parentH - totalSpacingY1) / rows;
                        if (this.keepSquare) {
                            ch = cw;
                        } else {
                            if (this.enforceAspect) {
                                ch = cw / UnityEngine.Mathf.Max(0.01, this.aspectWH);
                            }
                        }
                    }

                    var cellW = Math.max(this.minCell.x, Math.min(cw, this.maxCell.x));
                    var cellH = (this.keepSquare) ? cellW : (this.enforceAspect ? Math.max(this.minCell.y, Math.min(cellW / UnityEngine.Mathf.Max(0.01, this.aspectWH), this.maxCell.y)) : Math.max(this.minCell.y, Math.min(ch, this.maxCell.y)));
                    if (this.fitAxis === FluidGridLayout.FitAxis.HorizontalOnly) {
                        cellH = this.keepSquare ? cellW : cellH;
                    }
                    if (this.fitAxis === FluidGridLayout.FitAxis.VerticalOnly) {
                        cellW = this.keepSquare ? cellH : cellW;
                    }
                    // Compute raw used space
                    var usedW = cols * cellW + this.spacing.x * UnityEngine.Mathf.Max(0, ((cols - 1) | 0));
                    var usedH = rows * cellH + this.spacing.y * UnityEngine.Mathf.Max(0, ((rows - 1) | 0));
                    var fits = true;
                    var eps = 0.5;
                    if (this.overflow === FluidGridLayout.OverflowMode.ClampToParent) {
                        fits = (usedW <= parentW + eps) && (usedH <= parentH + eps);
                    } else if (this.overflow === FluidGridLayout.OverflowMode.ScaleDownToFit) {
                        // Uniformly scale down to fit inside parent if needed
                        var scaleX = (cols > 0) ? (parentW - this.spacing.x * UnityEngine.Mathf.Max(0, ((cols - 1) | 0))) / UnityEngine.Mathf.Max(1E-05, cols * cellW) : 1.0;
                        var scaleY = (rows > 0) ? (parentH - this.spacing.y * UnityEngine.Mathf.Max(0, ((rows - 1) | 0))) / UnityEngine.Mathf.Max(1E-05, rows * cellH) : 1.0;
                        var scale = UnityEngine.Mathf.Min(scaleX, scaleY, 1.0); // never scale up
                        if (scale < 1.0) {
                            var newW = cellW * scale;
                            var newH;
                            if (this.keepSquare || this.enforceAspect || this.preserveAspectOnScaleDown) {
                                // Preserve aspect/squareness
                                newH = cellH * scale;
                            } else {
                                // Non-uniform allowed (but still use same scale so both axes fit)
                                newH = cellH * scale;
                            }

                            if (this.respectMinCellOnScaleDown) {
                                newW = UnityEngine.Mathf.Max(this.minCell.x, newW);
                                newH = UnityEngine.Mathf.Max(this.minCell.y, newH);
                            }

                            newW = UnityEngine.Mathf.Min(newW, this.maxCell.x);
                            newH = UnityEngine.Mathf.Min(newH, this.maxCell.y);
                            cellW = newW;
                            cellH = newH;
                            usedW = cols * cellW + this.spacing.x * UnityEngine.Mathf.Max(0, ((cols - 1) | 0));
                            usedH = rows * cellH + this.spacing.y * UnityEngine.Mathf.Max(0, ((rows - 1) | 0));
                        }

                        fits = (usedW <= parentW + eps) && (usedH <= parentH + eps);
                    }

                    // AllowVerticalScroll: no strict fit check (height may exceed)
                    if (!fits) {
                        return;
                    }
                    // Score: prefer larger cell area; break ties by fewer rows, then fewer cols
                    var score = cellW * cellH * 1000.0 - rows * 1.0 - cols * 0.1;
                    if (score > bestScore) {
                        bestScore = score;
                        bestCols = cols;
                        bestRows = rows;
                        bestCell = new pc.Vec2( cellW, cellH );
                    }
                });

                // Search depending on constraint
                switch (this.constraint) {
                    case FluidGridLayout.Constraint.FixedColumns: 
                        Consider(this.constraintCount);
                        break;
                    case FluidGridLayout.Constraint.FixedRows: 
                        {
                            var rows = UnityEngine.Mathf.Max(1, this.constraintCount);
                            var cols = Math.ceil(childCount / rows);
                            Consider(cols);
                        }
                        break;
                    default: 
                        for (var cols1 = minCols; cols1 <= maxCols; cols1 = (cols1 + 1) | 0) {
                            Consider(cols1);
                        }
                        if (bestScore === Number.NEGATIVE_INFINITY) {
                            Consider(minCols);
                        }
                        break;
                }

                // Fallback in extreme cases
                if (bestScore === Number.NEGATIVE_INFINITY) {
                    bestCols = Math.max(1, Math.min(childCount, UnityEngine.Mathf.Max(1, this.columnsRange.y)));
                    bestRows = Math.ceil(childCount / bestCols);

                    var cw = UnityEngine.Mathf.Max(this.minCell.x, (parentW - this.spacing.x * UnityEngine.Mathf.Max(0, ((bestCols - 1) | 0))) / bestCols);
                    var ch = this.keepSquare ? cw : this.enforceAspect ? cw / UnityEngine.Mathf.Max(0.01, this.aspectWH) : (this.overflow === FluidGridLayout.OverflowMode.AllowVerticalScroll ? this.minCell.y : UnityEngine.Mathf.Max(this.minCell.y, (parentH - this.spacing.y * UnityEngine.Mathf.Max(0, ((bestRows - 1) | 0))) / bestRows));

                    bestCell = new pc.Vec2( Math.max(this.minCell.x, Math.min(cw, this.maxCell.x)), Math.max(this.minCell.y, Math.min(ch, this.maxCell.y)) );
                }

                this._chosenColumns = UnityEngine.Mathf.Max(1, bestCols);
                this._chosenRows = UnityEngine.Mathf.Max(1, bestRows);
                this._chosenCell = bestCell.$clone();
            },
            /*FluidGridLayout.ComputeLayout end.*/

            /*FluidGridLayout.ApplyChildrenLayout start.*/
            ApplyChildrenLayout: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#ApplyChildrenLayout", this ); }

                var rect = this.rectTransform.rect.$clone();
                if (this._chosenColumns <= 0 || this._chosenRows <= 0) {
                    return;
                }

                // Calculate total used space with chosen cell
                var usedW0 = this._chosenColumns * this._chosenCell.x + this.spacing.x * UnityEngine.Mathf.Max(0, ((this._chosenColumns - 1) | 0));
                var usedH0 = this._chosenRows * this._chosenCell.y + this.spacing.y * UnityEngine.Mathf.Max(0, ((this._chosenRows - 1) | 0));

                var parentW = UnityEngine.Mathf.Max(0, rect.width - this.padding.horizontal);
                var parentH = UnityEngine.Mathf.Max(0, rect.height - this.padding.vertical);

                // Copy spacing (may be modified for Justify)
                var spacingX = this.spacing.x;
                var spacingY = this.spacing.y;

                // Alignment start positions
                var startX = this.padding.left;
                var startY = this.padding.top;

                switch (this.horizontalAlign) {
                    case FluidGridLayout.HAlign.Center: 
                        startX = this.padding.left + UnityEngine.Mathf.Max(0, (parentW - usedW0) * 0.5);
                        break;
                    case FluidGridLayout.HAlign.End: 
                        startX = this.padding.left + UnityEngine.Mathf.Max(0, parentW - usedW0);
                        break;
                    case FluidGridLayout.HAlign.Justify: 
                        // base start left; spacing adjusted below
                        break;
                }
                if (this.centerX) {
                    startX = this.padding.left + UnityEngine.Mathf.Max(0, (parentW - usedW0) * 0.5);
                }

                switch (this.verticalAlign) {
                    case FluidGridLayout.VAlign.Center: 
                        startY = this.padding.top + UnityEngine.Mathf.Max(0, (parentH - usedH0) * 0.5);
                        break;
                    case FluidGridLayout.VAlign.End: 
                        startY = this.padding.top + UnityEngine.Mathf.Max(0, parentH - usedH0);
                        break;
                    case FluidGridLayout.VAlign.Justify: 
                        // base start top; spacing adjusted below
                        break;
                }
                if (this.centerY) {
                    startY = this.padding.top + UnityEngine.Mathf.Max(0, (parentH - usedH0) * 0.5);
                }

                // Adjust spacing for Justify (distribute remaining space)
                if (this.horizontalAlign === FluidGridLayout.HAlign.Justify && this._chosenColumns > 1 && parentW > usedW0) {
                    var freeW = UnityEngine.Mathf.Max(0, parentW - (this._chosenColumns * this._chosenCell.x));
                    spacingX = freeW / UnityEngine.Mathf.Max(1, ((this._chosenColumns - 1) | 0));
                }
                if (this.verticalAlign === FluidGridLayout.VAlign.Justify && this._chosenRows > 1 && parentH > usedH0) {
                    var freeH = UnityEngine.Mathf.Max(0, parentH - (this._chosenRows * this._chosenCell.y));
                    spacingY = freeH / UnityEngine.Mathf.Max(1, ((this._chosenRows - 1) | 0));
                }

                // Direction multipliers
                var dx = (this.horizontalDirection === FluidGridLayout.HorizontalDir.LeftToRight) ? 1 : -1;
                var dy = (this.verticalDirection === FluidGridLayout.VerticalDir.TopToBottom) ? 1 : -1;

                // Place children
                var activeCount = this.GetActiveChildCount();
                var placed = 0;

                for (var rawIndex = 0; rawIndex < this.rectTransform.childCount; rawIndex = (rawIndex + 1) | 0) {
                    var child = Bridge.as(this.rectTransform.GetChild(rawIndex), UnityEngine.RectTransform);
                    if (UnityEngine.Component.op_Equality(child, null) || !child.gameObject.activeInHierarchy) {
                        continue;
                    }

                    var displayIndex = Bridge.identity(placed, ((placed = (placed + 1) | 0)));

                    // Map index to row/col
                    var col, row;
                    if (this.order === FluidGridLayout.OrderMode.RowMajor) {
                        col = displayIndex % this._chosenColumns;
                        row = (Bridge.Int.div(displayIndex, this._chosenColumns)) | 0;
                    } else {
                        row = displayIndex % this._chosenRows;
                        col = (Bridge.Int.div(displayIndex, this._chosenRows)) | 0;
                    }

                    // Reverse mapping if requested
                    if (this.reverseOrder) {
                        var lastIndex = (((activeCount - 1) | 0) - displayIndex) | 0;
                        if (this.order === FluidGridLayout.OrderMode.RowMajor) {
                            col = lastIndex % this._chosenColumns;
                            row = (Bridge.Int.div(lastIndex, this._chosenColumns)) | 0;
                        } else {
                            row = lastIndex % this._chosenRows;
                            col = (Bridge.Int.div(lastIndex, this._chosenRows)) | 0;
                        }
                    }

                    // Apply direction flips
                    var drawCol = (dx === 1) ? col : (((((this._chosenColumns - 1) | 0) - col) | 0));
                    var drawRow = (dy === 1) ? row : (((((this._chosenRows - 1) | 0) - row) | 0));

                    var x = startX + drawCol * (this._chosenCell.x + spacingX);
                    var y = startY + drawRow * (this._chosenCell.y + spacingY);

                    if (this.snapToPixels) {
                        x = Math.round(x);
                        y = Math.round(y);
                    }

                    if (this.overrideChildSize) {
                        this.SetChildAlongAxis$1(child, 0, x, this.snapToPixels ? Math.round(this._chosenCell.x) : this._chosenCell.x);
                        this.SetChildAlongAxis$1(child, 1, y, this.snapToPixels ? Math.round(this._chosenCell.y) : this._chosenCell.y);
                    } else {
                        this.SetChildAlongAxis(child, 0, x);
                        this.SetChildAlongAxis(child, 1, y);
                    }
                }

                // ScrollRect support: grow content vertically
                if (this.overflow === FluidGridLayout.OverflowMode.AllowVerticalScroll && this._chosenColumns > 0 && this._chosenRows > 0) {
                    var contentH = this.padding.vertical + this._chosenRows * this._chosenCell.y + spacingY * UnityEngine.Mathf.Max(0, ((this._chosenRows - 1) | 0));
                    if (this.snapToPixels) {
                        contentH = Math.round(contentH);
                    }
                    this.rectTransform.SetSizeWithCurrentAnchors(UnityEngine.RectTransform.Axis.Vertical, contentH);
                }
            },
            /*FluidGridLayout.ApplyChildrenLayout end.*/

            /*FluidGridLayout.GetActiveChildCount start.*/
            GetActiveChildCount: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#GetActiveChildCount", this ); }

                var count = 0;
                for (var i = 0; i < this.rectTransform.childCount; i = (i + 1) | 0) {
                    var rt = Bridge.as(this.rectTransform.GetChild(i), UnityEngine.RectTransform);
                    if (UnityEngine.Component.op_Inequality(rt, null) && rt.gameObject.activeInHierarchy) {
                        count = (count + 1) | 0;
                    }
                }
                return count;
            },
            /*FluidGridLayout.GetActiveChildCount end.*/

            /*FluidGridLayout.OnRectTransformDimensionsChange start.*/
            OnRectTransformDimensionsChange: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#OnRectTransformDimensionsChange", this ); }

                UnityEngine.UI.LayoutGroup.prototype.OnRectTransformDimensionsChange.call(this);
                this.SetDirty$1();
            },
            /*FluidGridLayout.OnRectTransformDimensionsChange end.*/

            /*FluidGridLayout.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#OnEnable", this ); }

                UnityEngine.UI.LayoutGroup.prototype.OnEnable.call(this);
                this.SetDirty$1();
            },
            /*FluidGridLayout.OnEnable end.*/

            /*FluidGridLayout.OnTransformChildrenChanged start.*/
            OnTransformChildrenChanged: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#OnTransformChildrenChanged", this ); }

                UnityEngine.UI.LayoutGroup.prototype.OnTransformChildrenChanged.call(this);
                if (this.autoRebuildOnChildChange) {
                    this.SetDirty$1();
                }
            },
            /*FluidGridLayout.OnTransformChildrenChanged end.*/

            /*FluidGridLayout.SetDirty$1 start.*/
            SetDirty$1: function () {
if ( TRACE ) { TRACE( "FluidGridLayout#SetDirty$1", this ); }

                if (!this.IsActive()) {
                    return;
                }
                UnityEngine.UI.LayoutRebuilder.MarkLayoutForRebuild(this.rectTransform);
            },
            /*FluidGridLayout.SetDirty$1 end.*/


        },
        overloads: {
            "SetDirty()": "SetDirty$1"
        }
    });
    /*FluidGridLayout end.*/

    /*FluidGridLayout+Constraint start.*/
    Bridge.define("FluidGridLayout.Constraint", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                FixedColumns: 1,
                FixedRows: 2
            }
        }
    });
    /*FluidGridLayout+Constraint end.*/

    /*FluidGridLayout+FitAxis start.*/
    Bridge.define("FluidGridLayout.FitAxis", {
        $kind: 1006,
        statics: {
            fields: {
                Both: 0,
                HorizontalOnly: 1,
                VerticalOnly: 2
            }
        }
    });
    /*FluidGridLayout+FitAxis end.*/

    /*FluidGridLayout+HAlign start.*/
    Bridge.define("FluidGridLayout.HAlign", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 0,
                Center: 1,
                End: 2,
                Justify: 3
            }
        }
    });
    /*FluidGridLayout+HAlign end.*/

    /*FluidGridLayout+HorizontalDir start.*/
    Bridge.define("FluidGridLayout.HorizontalDir", {
        $kind: 1006,
        statics: {
            fields: {
                LeftToRight: 0,
                RightToLeft: 1
            }
        }
    });
    /*FluidGridLayout+HorizontalDir end.*/

    /*FluidGridLayout+OrderMode start.*/
    Bridge.define("FluidGridLayout.OrderMode", {
        $kind: 1006,
        statics: {
            fields: {
                RowMajor: 0,
                ColumnMajor: 1
            }
        }
    });
    /*FluidGridLayout+OrderMode end.*/

    /*FluidGridLayout+OverflowMode start.*/
    Bridge.define("FluidGridLayout.OverflowMode", {
        $kind: 1006,
        statics: {
            fields: {
                ClampToParent: 0,
                AllowVerticalScroll: 1,
                ScaleDownToFit: 2
            }
        }
    });
    /*FluidGridLayout+OverflowMode end.*/

    /*FluidGridLayout+VAlign start.*/
    Bridge.define("FluidGridLayout.VAlign", {
        $kind: 1006,
        statics: {
            fields: {
                Start: 0,
                Center: 1,
                End: 2,
                Justify: 3
            }
        }
    });
    /*FluidGridLayout+VAlign end.*/

    /*FluidGridLayout+VerticalDir start.*/
    Bridge.define("FluidGridLayout.VerticalDir", {
        $kind: 1006,
        statics: {
            fields: {
                TopToBottom: 0,
                BottomToTop: 1
            }
        }
    });
    /*FluidGridLayout+VerticalDir end.*/

    /*GameManager start.*/
    Bridge.define("GameManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            endPanel: null,
            end: false,
            hand: null,
            arrow: null,
            enableSound: false,
            startClickHandler: null,
            CurrentState: 0,
            currentScore: 0
        },
        props: {
            CurrentScore: {
                get: function () {
if ( TRACE ) { TRACE( "GameManager#CurrentScore#get", this ); }

                    return this.currentScore;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "GameManager#CurrentScore#set", this ); }

                    this.currentScore = value;
                }
            }
        },
        methods: {
            /*GameManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "GameManager#Awake", this ); }

                // Singleton setup
                if (UnityEngine.MonoBehaviour.op_Equality(GameManager.Instance, null)) {
                    GameManager.Instance = this;
                    UnityEngine.Object.DontDestroyOnLoad(this.gameObject);
                } else {
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                }
            },
            /*GameManager.Awake end.*/

            /*GameManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GameManager#Start", this ); }

                this.ChangeState(GameManager.GameState.MainMenu);
            },
            /*GameManager.Start end.*/

            /*GameManager.Win start.*/
            Win: function () {
if ( TRACE ) { TRACE( "GameManager#Win", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.endPanel.SetActive(true);
                                        this.end = true;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*GameManager.Win end.*/

            /*GameManager.DestroyHandObj start.*/
            DestroyHandObj: function () {
if ( TRACE ) { TRACE( "GameManager#DestroyHandObj", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(1.0);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    UnityEngine.MonoBehaviour.Destroy(this.hand.gameObject);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*GameManager.DestroyHandObj end.*/

            /*GameManager.CTAClicked start.*/
            CTAClicked: function () {
if ( TRACE ) { TRACE( "GameManager#CTAClicked", this ); }

                Luna.Unity.Playable.InstallFullGame("https://apps.apple.com/us/app/bid-wars-2-pawn-shop-tycoon/id1262445849", "https://play.google.com/store/apps/details?id=br.com.tapps.bidwars2");
                UnityEngine.Debug.Log$1("CTA Clicked");
            },
            /*GameManager.CTAClicked end.*/

            /*GameManager.ChangeState start.*/
            ChangeState: function (newState) {
if ( TRACE ) { TRACE( "GameManager#ChangeState", this ); }

                this.CurrentState = newState;

                switch (newState) {
                    case GameManager.GameState.MainMenu: 
                        UnityEngine.Time.timeScale = 1.0;
                        break;
                    case GameManager.GameState.Playing: 
                        UnityEngine.Time.timeScale = 1.0;
                        break;
                    case GameManager.GameState.Paused: 
                        UnityEngine.Time.timeScale = 0.0;
                        break;
                    case GameManager.GameState.GameOver: 
                        UnityEngine.Time.timeScale = 1.0;
                        break;
                }

                UnityEngine.Debug.Log$1("Game State changed to: " + System.Enum.toString(GameManager.GameState, newState));
            },
            /*GameManager.ChangeState end.*/

            /*GameManager.RestartGame start.*/
            RestartGame: function () {
if ( TRACE ) { TRACE( "GameManager#RestartGame", this ); }

                UnityEngine.SceneManagement.SceneManager.LoadScene$2(UnityEngine.SceneManagement.SceneManager.GetActiveScene().name);
                this.ChangeState(GameManager.GameState.Playing);
            },
            /*GameManager.RestartGame end.*/

            /*GameManager.StartMusic start.*/
            StartMusic: function () {
if ( TRACE ) { TRACE( "GameManager#StartMusic", this ); }

                AudioManager.Instance.PlayMusic("BGM");
            },
            /*GameManager.StartMusic end.*/


        }
    });
    /*GameManager end.*/

    /*GameManager+GameState start.*/
    Bridge.define("GameManager.GameState", {
        $kind: 1006,
        statics: {
            fields: {
                MainMenu: 0,
                Playing: 1,
                Paused: 2,
                GameOver: 3
            }
        }
    });
    /*GameManager+GameState end.*/

    /*HorizontalUIDragClamp start.*/
    Bridge.define("HorizontalUIDragClamp", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IBeginDragHandler,UnityEngine.EventSystems.IDragHandler,UnityEngine.EventSystems.IEndDragHandler],
        fields: {
            smooth: false,
            smoothSpeed: 0,
            leftPadding: 0,
            rightPadding: 0,
            requireRaycastTarget: false,
            rt: null,
            parent: null,
            rootCanvas: null,
            uiCam: null,
            targetAnchoredPos: null,
            dragging: false
        },
        alias: [
            "OnBeginDrag", "UnityEngine$EventSystems$IBeginDragHandler$OnBeginDrag",
            "OnDrag", "UnityEngine$EventSystems$IDragHandler$OnDrag",
            "OnEndDrag", "UnityEngine$EventSystems$IEndDragHandler$OnEndDrag"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "HorizontalUIDragClamp#init", this ); }

                this.targetAnchoredPos = new UnityEngine.Vector2();
                this.smooth = false;
                this.smoothSpeed = 18.0;
                this.leftPadding = 0.0;
                this.rightPadding = 0.0;
                this.requireRaycastTarget = true;
            }
        },
        methods: {
            /*HorizontalUIDragClamp.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "HorizontalUIDragClamp#Awake", this ); }

                var $t;
                this.rt = this.GetComponent(UnityEngine.RectTransform);
                this.parent = Bridge.as(this.rt.parent, UnityEngine.RectTransform);
                this.rootCanvas = UnityEngine.Component.op_Inequality(($t = this.GetComponentInParent(UnityEngine.Canvas)), null) ? $t.rootCanvas : null;
                this.uiCam = (UnityEngine.Object.op_Implicit(this.rootCanvas) && this.rootCanvas.renderMode === UnityEngine.RenderMode.ScreenSpaceCamera) ? this.rootCanvas.worldCamera : null;
                this.targetAnchoredPos = this.rt.anchoredPosition.$clone();
            },
            /*HorizontalUIDragClamp.Awake end.*/

            /*HorizontalUIDragClamp.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "HorizontalUIDragClamp#Update", this ); }

                if (this.smooth && UnityEngine.Application.isPlaying) {
                    // Exponential smoothing towards targetAnchoredPos (x only)
                    var cur = this.rt.anchoredPosition.$clone();
                    var t = 1.0 - UnityEngine.Mathf.Exp(-this.smoothSpeed * UnityEngine.Time.unscaledDeltaTime);
                    cur.x = pc.math.lerp(cur.x, this.targetAnchoredPos.x, t);
                    this.rt.anchoredPosition = cur.$clone();
                }
            },
            /*HorizontalUIDragClamp.Update end.*/

            /*HorizontalUIDragClamp.OnBeginDrag start.*/
            OnBeginDrag: function (eventData) {
if ( TRACE ) { TRACE( "HorizontalUIDragClamp#OnBeginDrag", this ); }

                if (!this.IsDragValid(eventData)) {
                    return;
                }
                this.dragging = true;
                this.targetAnchoredPos = this.rt.anchoredPosition.$clone();
            },
            /*HorizontalUIDragClamp.OnBeginDrag end.*/

            /*HorizontalUIDragClamp.OnDrag start.*/
            OnDrag: function (eventData) {
if ( TRACE ) { TRACE( "HorizontalUIDragClamp#OnDrag", this ); }

                if (!this.dragging || UnityEngine.Component.op_Equality(this.parent, null) || UnityEngine.Component.op_Equality(this.rootCanvas, null)) {
                    return;
                }

                // Move horizontally in anchored units
                var deltaX = eventData.delta.x / UnityEngine.Mathf.Max(0.001, this.rootCanvas.scaleFactor);
                var proposed = this.rt.anchoredPosition.$clone();
                proposed.x += deltaX;

                // Apply, then clamp within parent horizontally
                if (this.smooth) {
                    this.targetAnchoredPos = proposed.$clone();
                } else {
                    this.rt.anchoredPosition = proposed.$clone();
                }
                this.ClampWithinParentHorizontal(); // will adjust anchoredPosition/targetAnchoredPos
            },
            /*HorizontalUIDragClamp.OnDrag end.*/

            /*HorizontalUIDragClamp.OnEndDrag start.*/
            OnEndDrag: function (eventData) {
if ( TRACE ) { TRACE( "HorizontalUIDragClamp#OnEndDrag", this ); }

                this.dragging = false;
                // Final safety clamp
                this.ClampWithinParentHorizontal();
            },
            /*HorizontalUIDragClamp.OnEndDrag end.*/

            /*HorizontalUIDragClamp.IsDragValid start.*/
            IsDragValid: function (e) {
if ( TRACE ) { TRACE( "HorizontalUIDragClamp#IsDragValid", this ); }

                if (!this.requireRaycastTarget) {
                    return true;
                }
                // Ensure this element (or its children) received the raycast
                return UnityEngine.Object.op_Implicit(e.pointerEnter) && (UnityEngine.GameObject.op_Equality(e.pointerEnter, this.gameObject) || e.pointerEnter.transform.IsChildOf(this.transform));
            },
            /*HorizontalUIDragClamp.IsDragValid end.*/

            /*HorizontalUIDragClamp.ClampWithinParentHorizontal start.*/
            ClampWithinParentHorizontal: function () {
if ( TRACE ) { TRACE( "HorizontalUIDragClamp#ClampWithinParentHorizontal", this ); }

                if (UnityEngine.Component.op_Equality(this.parent, null)) {
                    return;
                }

                // Get world corners for parent and self
                var pc = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                var sc = System.Array.init(4, function (){
                    return new UnityEngine.Vector3();
                }, UnityEngine.Vector3);
                this.parent.GetWorldCorners(pc);
                this.rt.GetWorldCorners(sc);

                var parentLeftW = pc[0].x + this.leftPadding; // bottom-left.x
                var parentRightW = pc[2].x - this.rightPadding; // top-right.x
                var selfLeftW = sc[0].x;
                var selfRightW = sc[2].x;

                var worldDx = 0.0;
                if (selfLeftW < parentLeftW) {
                    worldDx = parentLeftW - selfLeftW;
                } else {
                    if (selfRightW > parentRightW) {
                        worldDx = parentRightW - selfRightW;
                    }
                }

                if (UnityEngine.Mathf.Approximately(worldDx, 0.0)) {
                    return;
                }

                // Convert world delta X to parent local space delta X
                var localDelta3 = this.parent.InverseTransformVector(new pc.Vec3( worldDx, 0.0, 0.0 ));
                var localDx = localDelta3.x;

                if (this.smooth) {
                    var t = this.targetAnchoredPos.$clone();
                    t.x += localDx;
                    this.targetAnchoredPos = t.$clone();
                } else {
                    var p = this.rt.anchoredPosition.$clone();
                    p.x += localDx;
                    this.rt.anchoredPosition = p.$clone();
                }

                // Optional: re-check once in case of extreme scales/rotations
                // (usually not necessary, but cheap)
                this.rt.GetWorldCorners(sc);
                selfLeftW = sc[0].x;
                selfRightW = sc[2].x;
                if (selfLeftW < parentLeftW || selfRightW > parentRightW) {
                    var fix3 = this.parent.InverseTransformVector(new pc.Vec3( Math.max(parentLeftW - selfLeftW, Math.min(0.0, parentRightW - selfRightW)), 0.0, 0.0 ));
                    if (this.smooth) {
                        this.targetAnchoredPos.x += fix3.x;
                    } else {
                        var p2 = this.rt.anchoredPosition.$clone();
                        p2.x += fix3.x;
                        this.rt.anchoredPosition = p2.$clone();
                    }
                }
            },
            /*HorizontalUIDragClamp.ClampWithinParentHorizontal end.*/


        }
    });
    /*HorizontalUIDragClamp end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*OrientationLayoutSwitcher start.*/
    Bridge.define("OrientationLayoutSwitcher", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            portraitRoot: null,
            landscapeRoot: null,
            applySafeAreaToRoots: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "OrientationLayoutSwitcher#init", this ); }

                this.applySafeAreaToRoots = false;
            }
        },
        methods: {
            /*OrientationLayoutSwitcher.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "OrientationLayoutSwitcher#OnEnable", this ); }

                ResponsiveUIManager.addOnOrientationChanged(Bridge.fn.cacheBind(this, this.Handle));
                // Initialize immediately with current orientation guess
                var o = UnityEngine.Screen.width >= UnityEngine.Screen.height ? UnityEngine.ScreenOrientation.LandscapeLeft : UnityEngine.ScreenOrientation.Portrait;
                this.Handle(o);
            },
            /*OrientationLayoutSwitcher.OnEnable end.*/

            /*OrientationLayoutSwitcher.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "OrientationLayoutSwitcher#OnDisable", this ); }

                ResponsiveUIManager.removeOnOrientationChanged(Bridge.fn.cacheBind(this, this.Handle));
            },
            /*OrientationLayoutSwitcher.OnDisable end.*/

            /*OrientationLayoutSwitcher.Handle start.*/
            Handle: function (o) {
if ( TRACE ) { TRACE( "OrientationLayoutSwitcher#Handle", this ); }

                var portrait = (o === UnityEngine.ScreenOrientation.Portrait);
                if (UnityEngine.Object.op_Implicit(this.portraitRoot)) {
                    this.portraitRoot.SetActive(portrait);
                }
                if (UnityEngine.Object.op_Implicit(this.landscapeRoot)) {
                    this.landscapeRoot.SetActive(!portrait);
                }

                if (this.applySafeAreaToRoots) {
                    this.ApplySafe(portrait ? this.portraitRoot : this.landscapeRoot);
                }
            },
            /*OrientationLayoutSwitcher.Handle end.*/

            /*OrientationLayoutSwitcher.ApplySafe start.*/
            ApplySafe: function (root) {
if ( TRACE ) { TRACE( "OrientationLayoutSwitcher#ApplySafe", this ); }

                var $t;
                if (!UnityEngine.Object.op_Implicit(root)) {
                    return;
                }
                var rt = root.GetComponent(UnityEngine.RectTransform);
                if (!UnityEngine.Object.op_Implicit(rt)) {
                    return;
                }

                var sa = UnityEngine.Screen.safeArea.$clone();
                var w = UnityEngine.Mathf.Max(1, UnityEngine.Screen.width);
                var h = UnityEngine.Mathf.Max(1, UnityEngine.Screen.height);

                var min = sa.position.$clone();
                var max = sa.position.$clone().add( sa.size );
                min.x /= w;
                min.y /= h;
                max.x /= w;
                max.y /= h;

                rt.anchorMin = min.$clone();
                rt.anchorMax = max.$clone();
                rt.offsetMin = ($t = pc.Vec2.ZERO.clone(), rt.offsetMax = $t.$clone(), $t);
            },
            /*OrientationLayoutSwitcher.ApplySafe end.*/


        }
    });
    /*OrientationLayoutSwitcher end.*/

    /*ReadOnlyAttribute start.*/
    Bridge.define("ReadOnlyAttribute", {
        inherits: [UnityEngine.PropertyAttribute]
    });
    /*ReadOnlyAttribute end.*/

    /*ResponsiveUIManager start.*/
    Bridge.define("ResponsiveUIManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            events: {
                OnOrientationChanged: null
            }
        },
        fields: {
            forceOrientation: 0,
            portraitReferenceResolution: null,
            landscapeReferenceResolution: null,
            _lastOrientation: 0,
            manageCanvasScaler: false,
            referenceResolution: null,
            defaultMatchWidthOrHeight: 0,
            useOrientationAgnosticAspect: false,
            aspectProfiles: null,
            enableDpiClamp: false,
            dpiClampThreshold: 0,
            dpiClampMax: 0,
            safeAreaPanels: null,
            strictAspectPanels: null,
            disableDecorativeRaycasts: false,
            showDebugOverlay: false,
            debugTextShadow: null,
            debugTextSize: 0,
            overrideAspectProfile: false,
            overrideAspectProfileIndex: 0,
            activeAspectProfileIndex: 0,
            activeAspectProfileLabel: null,
            _canvas: null,
            _scaler: null,
            _lastScreen: null,
            _lastSafe: null,
            _lastDpi: 0,
            _lastMatch: 0,
            _lastDpp: 0,
            _cachedDeviceDpi: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#init", this ); }

                var $t;
                this.portraitReferenceResolution = new UnityEngine.Vector2();
                this.landscapeReferenceResolution = new UnityEngine.Vector2();
                this.referenceResolution = new UnityEngine.Vector2();
                this.debugTextShadow = new UnityEngine.Color();
                this._lastScreen = new UnityEngine.Vector2();
                this._lastSafe = new UnityEngine.Rect();
                this.forceOrientation = ResponsiveUIManager.OrientationMode.Auto;
                this.portraitReferenceResolution = new pc.Vec2( 1080, 1920 );
                this.landscapeReferenceResolution = new pc.Vec2( 1920, 1080 );
                this.manageCanvasScaler = true;
                this.referenceResolution = new pc.Vec2( 1080, 1920 );
                this.defaultMatchWidthOrHeight = 0.5;
                this.useOrientationAgnosticAspect = true;
                this.aspectProfiles = System.Array.init([($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 1.0, $t.matchWidthOrHeight = 0.0, $t.label = "1:1 Square \u2192 favor height", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 1.25, $t.matchWidthOrHeight = 0.0, $t.label = "5:4 (1.25) \u2192 favor height", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 1.33333337, $t.matchWidthOrHeight = 0.0, $t.label = "4:3 (1.33) tablets \u2192 favor height", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 1.5, $t.matchWidthOrHeight = 0.0, $t.label = "3:2 (1.50) \u2192 favor height", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 1.6, $t.matchWidthOrHeight = 0.0, $t.label = "16:10 (1.60) \u2192 favor height", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 1.77777779, $t.matchWidthOrHeight = 0.5, $t.label = "16:9 (1.78) \u2192 balanced (TVs, older phones)", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 1.88888884, $t.matchWidthOrHeight = 0.5, $t.label = "17:9 (1.89) \u2192 balanced (cinema-ish)", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 1.9, $t.matchWidthOrHeight = 0.5, $t.label = "19:10 (1.90) \u2192 balanced", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 2.0, $t.matchWidthOrHeight = 1.0, $t.label = "18:9 / 2:1 (2.00) \u2192 favor width (portrait)", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 2.11111116, $t.matchWidthOrHeight = 1.0, $t.label = "19:9 (2.11) \u2192 favor width (portrait)", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 2.16666675, $t.matchWidthOrHeight = 1.0, $t.label = "19.5:9 (2.17) \u2192 favor width (portrait)", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 2.19999981, $t.matchWidthOrHeight = 1.0, $t.label = "19.8:9 (2.20) \u2192 favor width (portrait)", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 2.22222233, $t.matchWidthOrHeight = 1.0, $t.label = "20:9 (2.22) \u2192 favor width (portrait)", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 2.33333325, $t.matchWidthOrHeight = 0.0, $t.label = "21:9 (2.33) \u2192 favor height (landscape ultrawide)", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 2.44444442, $t.matchWidthOrHeight = 0.0, $t.label = "22:9 (2.44) \u2192 favor height (landscape ultrawide)", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 2.55555558, $t.matchWidthOrHeight = 0.0, $t.label = "23:9 (2.56) \u2192 favor height (landscape ultrawide)", $t), ($t = new ResponsiveUIManager.AspectProfile(), $t.maxAspect = 3.0, $t.matchWidthOrHeight = 1.0, $t.label = "\u22652.56\u20133.00 \u2192 favor width (extreme tall portrait / folds)", $t)], ResponsiveUIManager.AspectProfile);
                this.enableDpiClamp = true;
                this.dpiClampThreshold = 450.0;
                this.dpiClampMax = 450.0;
                this.disableDecorativeRaycasts = true;
                this.showDebugOverlay = true;
                this.debugTextShadow = new pc.Color( 0, 0, 0, 0.5 );
                this.debugTextSize = 11;
                this.overrideAspectProfile = false;
                this.overrideAspectProfileIndex = 0;
                this.activeAspectProfileIndex = -1;
                this.activeAspectProfileLabel = "";
            }
        },
        methods: {
            /*ResponsiveUIManager.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#Reset", this ); }

                this.TryCache();
                if (UnityEngine.Object.op_Implicit(this._scaler)) {
                    this._scaler.uiScaleMode = UnityEngine.UI.CanvasScaler.ScaleMode.ScaleWithScreenSize;
                    this._scaler.referenceResolution = this.referenceResolution.$clone();
                    this._scaler.screenMatchMode = UnityEngine.UI.CanvasScaler.ScreenMatchMode.MatchWidthOrHeight;
                    this._scaler.matchWidthOrHeight = this.defaultMatchWidthOrHeight;
                }
            },
            /*ResponsiveUIManager.Reset end.*/

            /*ResponsiveUIManager.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#OnEnable", this ); }

                this.TryCache();
                this._lastOrientation = this.DetectOrientation();
                this.ApplyOrientation(this._lastOrientation, true);
                this.ApplyAll(true);

            },
            /*ResponsiveUIManager.OnEnable end.*/

            /*ResponsiveUIManager.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#OnDisable", this ); }
 },
            /*ResponsiveUIManager.OnDisable end.*/

            /*ResponsiveUIManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#Update", this ); }

                this.ApplyFrame();
            },
            /*ResponsiveUIManager.Update end.*/

            /*ResponsiveUIManager.ApplyFrame start.*/
            ApplyFrame: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#ApplyFrame", this ); }

                // Orientation check first
                var current = this.DetectOrientation();
                if (current !== this._lastOrientation) {
                    this._lastOrientation = current;
                    this.ApplyOrientation(current, true);
                    !Bridge.staticEquals(ResponsiveUIManager.OnOrientationChanged, null) ? ResponsiveUIManager.OnOrientationChanged(current) : null; // notify subscribers (layout switchers)
                }

                // Then general updates
                this.ApplyAll();
            },
            /*ResponsiveUIManager.ApplyFrame end.*/

            /*ResponsiveUIManager.TryCache start.*/
            TryCache: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#TryCache", this ); }

                if (!UnityEngine.Object.op_Implicit(this._canvas)) {
                    this._canvas = this.GetComponent(UnityEngine.Canvas);
                }
                if (!UnityEngine.Object.op_Implicit(this._scaler)) {
                    this._scaler = this.GetComponent(UnityEngine.UI.CanvasScaler);
                }
                if (UnityEngine.Object.op_Implicit(this._scaler) && this._scaler.uiScaleMode !== UnityEngine.UI.CanvasScaler.ScaleMode.ScaleWithScreenSize) {
                    this._scaler.uiScaleMode = UnityEngine.UI.CanvasScaler.ScaleMode.ScaleWithScreenSize;
                }
                if (this._cachedDeviceDpi <= 0.0) {
                    this._cachedDeviceDpi = UnityEngine.Mathf.Max(UnityEngine.Screen.dpi, 0.0);
                }
            },
            /*ResponsiveUIManager.TryCache end.*/

            /*ResponsiveUIManager.DetectOrientation start.*/
            DetectOrientation: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#DetectOrientation", this ); }

                if (this.forceOrientation === ResponsiveUIManager.OrientationMode.Portrait) {
                    return UnityEngine.ScreenOrientation.Portrait;
                }
                if (this.forceOrientation === ResponsiveUIManager.OrientationMode.Landscape) {
                    return UnityEngine.ScreenOrientation.LandscapeLeft;
                }
                return UnityEngine.Screen.width >= UnityEngine.Screen.height ? UnityEngine.ScreenOrientation.LandscapeLeft : UnityEngine.ScreenOrientation.Portrait;
            },
            /*ResponsiveUIManager.DetectOrientation end.*/

            /*ResponsiveUIManager.ApplyOrientation start.*/
            ApplyOrientation: function (o, force) {
if ( TRACE ) { TRACE( "ResponsiveUIManager#ApplyOrientation", this ); }

                if (!this.manageCanvasScaler || !UnityEngine.Object.op_Implicit(this._scaler)) {
                    return;
                }

                // Use dedicated ref res per orientation; if left to (0,0), fall back to referenceResolution
                var useRef = this.referenceResolution.$clone();
                if (o === UnityEngine.ScreenOrientation.Portrait && !pc.Vec2.equals( this.portraitReferenceResolution, pc.Vec2.ZERO.clone() )) {
                    useRef = this.portraitReferenceResolution.$clone();
                } else {
                    if (o === UnityEngine.ScreenOrientation.LandscapeLeft && !pc.Vec2.equals( this.landscapeReferenceResolution, pc.Vec2.ZERO.clone() )) {
                        useRef = this.landscapeReferenceResolution.$clone();
                    }
                }

                if (force || !pc.Vec2.equals( this._scaler.referenceResolution, useRef )) {
                    this._scaler.referenceResolution = useRef.$clone();
                }
            },
            /*ResponsiveUIManager.ApplyOrientation end.*/

            /*ResponsiveUIManager.ApplyAll start.*/
            ApplyAll: function (force) {
if ( TRACE ) { TRACE( "ResponsiveUIManager#ApplyAll", this ); }

                if (force === void 0) { force = false; }
                var w = UnityEngine.Screen.width;
                var h = UnityEngine.Mathf.Max(1, UnityEngine.Screen.height);
                var dpi = UnityEngine.Mathf.Max(UnityEngine.Screen.dpi, this._cachedDeviceDpi);

                var changed = force || !UnityEngine.Mathf.Approximately(this._lastScreen.x, w) || !UnityEngine.Mathf.Approximately(this._lastScreen.y, h) || !UnityEngine.Mathf.Approximately(this._lastDpi, dpi) || UnityEngine.Rect.op_Inequality(UnityEngine.Screen.safeArea.$clone(), this._lastSafe.$clone());

                if (!changed) {
                    return;
                }

                this._lastScreen = new pc.Vec2( w, h );
                this._lastDpi = dpi;
                this._lastSafe = UnityEngine.Screen.safeArea.$clone();

                // --- re-cache after reloads / prefab ops ---
                if (UnityEngine.Component.op_Equality(this._canvas, null) || UnityEngine.MonoBehaviour.op_Equality(this._scaler, null)) {
                    this.TryCache();
                }

                if (this.manageCanvasScaler && UnityEngine.Object.op_Implicit(this._scaler)) {
                    this._scaler.screenMatchMode = UnityEngine.UI.CanvasScaler.ScreenMatchMode.MatchWidthOrHeight;
                    this._scaler.matchWidthOrHeight = this.ChooseMatchByAspect(w, h, this.defaultMatchWidthOrHeight);

                    // DPI legibility clamp
                    var effectiveDpi = dpi;
                    if (this.enableDpiClamp && dpi > this.dpiClampThreshold) {
                        effectiveDpi = UnityEngine.Mathf.Min(dpi, this.dpiClampMax);
                    }

                    // Your DPP formula (visual density)
                    var dpp = Math.max(1.0, Math.min(1.0 * UnityEngine.Mathf.Max(1.0, effectiveDpi / 326.0), 2.25));

                    if (!UnityEngine.Mathf.Approximately(this._lastDpp, dpp)) {
                        // Try CanvasScaler.dynamicPixelsPerUnit via reflection (works across runtimes)
                        var set = this.TrySetDynamicPixelsPerUnit(this._scaler, dpp);

                        if (!set) {
                            // Fallback: adjust referencePixelsPerUnit (effective crispness)
                            var baseline = UnityEngine.Mathf.Max(1.0, this._scaler.referencePixelsPerUnit);
                            this._scaler.referencePixelsPerUnit = Math.max(50.0, Math.min(baseline * (dpp / 1.0), 400.0));
                        }

                        this._lastDpp = dpp;
                    }
                    this._lastMatch = this._scaler.matchWidthOrHeight;
                }

                // Layout adjustments
                this.ApplySafeArea();
                this.ApplyStrictAspect();
                if (this.disableDecorativeRaycasts) {
                    this.StripDecorativeRaycasts();
                }
            },
            /*ResponsiveUIManager.ApplyAll end.*/

            /*ResponsiveUIManager.TrySetDynamicPixelsPerUnit start.*/
            TrySetDynamicPixelsPerUnit: function (scaler, value) {
if ( TRACE ) { TRACE( "ResponsiveUIManager#TrySetDynamicPixelsPerUnit", this ); }

                try {
                    var prop = Bridge.Reflection.getMembers(UnityEngine.UI.CanvasScaler, 16, 284, "dynamicPixelsPerUnit");
                    if (prop != null && (!!prop.s)) {
                        Bridge.Reflection.midel(prop.s, scaler).apply(null, (null || []).concat(value));
                        return true;
                    }
                } catch ($e1) {
                    $e1 = System.Exception.create($e1); /* ignore */
                }
                return false;
            },
            /*ResponsiveUIManager.TrySetDynamicPixelsPerUnit end.*/

            /*ResponsiveUIManager.ChooseMatchByAspect start.*/
            ChooseMatchByAspect: function (width, height, fallback) {
if ( TRACE ) { TRACE( "ResponsiveUIManager#ChooseMatchByAspect", this ); }

                this.activeAspectProfileIndex = -1;
                this.activeAspectProfileLabel = "";

                if (this.aspectProfiles == null || this.aspectProfiles.length === 0) {
                    return fallback;
                }

                // Manual override wins
                if (this.overrideAspectProfile) {
                    var idx = Math.max(0, Math.min(this.overrideAspectProfileIndex, ((this.aspectProfiles.length - 1) | 0)));
                    var p = this.aspectProfiles[idx].$clone();
                    this.activeAspectProfileIndex = idx;
                    this.activeAspectProfileLabel = p.label;
                    return this.AdjustForOrientation(p.matchWidthOrHeight);
                }

                var aspect = this.useOrientationAgnosticAspect ? (UnityEngine.Mathf.Max(width, height) / UnityEngine.Mathf.Max(1.0, UnityEngine.Mathf.Min(width, height))) : (width / UnityEngine.Mathf.Max(1.0, height));

                var chosenIndex = (this.aspectProfiles.length - 1) | 0;
                for (var i = 0; i < this.aspectProfiles.length; i = (i + 1) | 0) {
                    if (aspect <= this.aspectProfiles[i].maxAspect) {
                        chosenIndex = i;
                        break;
                    }
                }

                var chosen = this.aspectProfiles[chosenIndex].$clone();
                this.activeAspectProfileIndex = chosenIndex;
                this.activeAspectProfileLabel = chosen.label;

                return this.AdjustForOrientation(chosen.matchWidthOrHeight);
            },
            /*ResponsiveUIManager.ChooseMatchByAspect end.*/

            /*ResponsiveUIManager.AdjustForOrientation start.*/
            AdjustForOrientation: function (value) {
if ( TRACE ) { TRACE( "ResponsiveUIManager#AdjustForOrientation", this ); }

                // In portrait  use as-is
                // In landscape  reverse (1 - value)
                var isLandscape = (this.forceOrientation === ResponsiveUIManager.OrientationMode.Landscape) || (this.forceOrientation === ResponsiveUIManager.OrientationMode.Auto && UnityEngine.Screen.width >= UnityEngine.Screen.height);

                return isLandscape ? 1.0 - value : value;
            },
            /*ResponsiveUIManager.AdjustForOrientation end.*/

            /*ResponsiveUIManager.ApplySafeArea start.*/
            ApplySafeArea: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#ApplySafeArea", this ); }

                var $t;
                if (this.safeAreaPanels == null) {
                    return;
                }

                var sa = UnityEngine.Screen.safeArea.$clone();
                var w = UnityEngine.Mathf.Max(1, UnityEngine.Screen.width);
                var h = UnityEngine.Mathf.Max(1, UnityEngine.Screen.height);

                var min = sa.position.$clone();
                var max = sa.position.$clone().add( sa.size );
                min.x /= w;
                min.y /= h;
                max.x /= w;
                max.y /= h;

                for (var i = 0; i < this.safeAreaPanels.length; i = (i + 1) | 0) {
                    var rt = this.safeAreaPanels[i];
                    if (!UnityEngine.Object.op_Implicit(rt)) {
                        continue;
                    }
                    rt.anchorMin = min.$clone();
                    rt.anchorMax = max.$clone();
                    rt.offsetMin = ($t = pc.Vec2.ZERO.clone(), rt.offsetMax = $t.$clone(), $t);
                }
            },
            /*ResponsiveUIManager.ApplySafeArea end.*/

            /*ResponsiveUIManager.ApplyStrictAspect start.*/
            ApplyStrictAspect: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#ApplyStrictAspect", this ); }

                var $t, $t1;
                if (this.strictAspectPanels == null) {
                    return;
                }

                var screenAspect = UnityEngine.Screen.width / UnityEngine.Mathf.Max(1, UnityEngine.Screen.height);
                $t = Bridge.getEnumerator(this.strictAspectPanels);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current.$clone();
                        if (!UnityEngine.Object.op_Implicit(entry.panel)) {
                            continue;
                        }
                        var rt = entry.panel;

                        var targetAspect = entry.targetAspect > 0.0 ? entry.targetAspect : this.referenceResolution.x / UnityEngine.Mathf.Max(1.0, this.referenceResolution.y);

                        if (screenAspect > targetAspect) {
                            // Wider than target  clamp width
                            var widthScale = targetAspect / screenAspect;
                            var side = (1.0 - widthScale) * 0.5;
                            rt.anchorMin = new pc.Vec2( side, 0.0 );
                            rt.anchorMax = new pc.Vec2( 1.0 - side, 1.0 );
                        } else {
                            // Taller than target  clamp height
                            var heightScale = screenAspect / targetAspect;
                            var tb = (1.0 - heightScale) * 0.5;
                            rt.anchorMin = new pc.Vec2( 0.0, tb );
                            rt.anchorMax = new pc.Vec2( 1.0, 1.0 - tb );
                        }
                        rt.offsetMin = ($t1 = pc.Vec2.ZERO.clone(), rt.offsetMax = $t1.$clone(), $t1);

                        if (UnityEngine.Object.op_Implicit(entry.backgroundBars)) {
                            entry.backgroundBars.enabled = true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*ResponsiveUIManager.ApplyStrictAspect end.*/

            /*ResponsiveUIManager.StripDecorativeRaycasts start.*/
            StripDecorativeRaycasts: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#StripDecorativeRaycasts", this ); }

                if (!UnityEngine.Object.op_Implicit(this._canvas)) {
                    return;
                }
                var images = this.GetComponentsInChildren$1(UnityEngine.UI.Image, true);
                for (var i = 0; i < images.length; i = (i + 1) | 0) {
                    var img = images[i];
                    if (!UnityEngine.Object.op_Implicit(img)) {
                        continue;
                    }

                    // Use array API with includeInactive overload (works across runtimes)
                    var interactive = img.transform.GetComponentsInParent$1(UnityEngine.UI.Selectable, true).length > 0;

                    if (!interactive && img.raycastTarget) {
                        img.raycastTarget = false;
                    }
                }
            },
            /*ResponsiveUIManager.StripDecorativeRaycasts end.*/

            /*ResponsiveUIManager.ForceAspectProfile start.*/
            ForceAspectProfile: function (index) {
if ( TRACE ) { TRACE( "ResponsiveUIManager#ForceAspectProfile", this ); }

                this.overrideAspectProfile = true;
                this.overrideAspectProfileIndex = Math.max(0, Math.min(index, ((this.aspectProfiles.length - 1) | 0)));
                this.ApplyAll(true);
            },
            /*ResponsiveUIManager.ForceAspectProfile end.*/

            /*ResponsiveUIManager.ClearAspectProfileOverride start.*/
            ClearAspectProfileOverride: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager#ClearAspectProfileOverride", this ); }

                this.overrideAspectProfile = false;
                this.ApplyAll(true);
            },
            /*ResponsiveUIManager.ClearAspectProfileOverride end.*/


        }
    });
    /*ResponsiveUIManager end.*/

    /*ResponsiveUIManager+AspectProfile start.*/
    Bridge.define("ResponsiveUIManager.AspectProfile", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager.AspectProfile#getDefaultValue", this ); }
 return new ResponsiveUIManager.AspectProfile(); }
            }
        },
        fields: {
            maxAspect: 0,
            matchWidthOrHeight: 0,
            label: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager.AspectProfile#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager.AspectProfile#getHashCode", this ); }

                var h = Bridge.addHash([5438590584, this.maxAspect, this.matchWidthOrHeight, this.label]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "ResponsiveUIManager.AspectProfile#equals", this ); }

                if (!Bridge.is(o, ResponsiveUIManager.AspectProfile)) {
                    return false;
                }
                return Bridge.equals(this.maxAspect, o.maxAspect) && Bridge.equals(this.matchWidthOrHeight, o.matchWidthOrHeight) && Bridge.equals(this.label, o.label);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "ResponsiveUIManager.AspectProfile#$clone", this ); }

                var s = to || new ResponsiveUIManager.AspectProfile();
                s.maxAspect = this.maxAspect;
                s.matchWidthOrHeight = this.matchWidthOrHeight;
                s.label = this.label;
                return s;
            }
        }
    });
    /*ResponsiveUIManager+AspectProfile end.*/

    /*ResponsiveUIManager+OrientationMode start.*/
    Bridge.define("ResponsiveUIManager.OrientationMode", {
        $kind: 1006,
        statics: {
            fields: {
                Auto: 0,
                Portrait: 1,
                Landscape: 2
            }
        }
    });
    /*ResponsiveUIManager+OrientationMode end.*/

    /*ResponsiveUIManager+StrictAspectEntry start.*/
    Bridge.define("ResponsiveUIManager.StrictAspectEntry", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager.StrictAspectEntry#getDefaultValue", this ); }
 return new ResponsiveUIManager.StrictAspectEntry(); }
            }
        },
        fields: {
            panel: null,
            targetAspect: 0,
            backgroundBars: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager.StrictAspectEntry#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "ResponsiveUIManager.StrictAspectEntry#getHashCode", this ); }

                var h = Bridge.addHash([7575682276, this.panel, this.targetAspect, this.backgroundBars]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "ResponsiveUIManager.StrictAspectEntry#equals", this ); }

                if (!Bridge.is(o, ResponsiveUIManager.StrictAspectEntry)) {
                    return false;
                }
                return Bridge.equals(this.panel, o.panel) && Bridge.equals(this.targetAspect, o.targetAspect) && Bridge.equals(this.backgroundBars, o.backgroundBars);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "ResponsiveUIManager.StrictAspectEntry#$clone", this ); }

                var s = to || new ResponsiveUIManager.StrictAspectEntry();
                s.panel = this.panel;
                s.targetAspect = this.targetAspect;
                s.backgroundBars = this.backgroundBars;
                return s;
            }
        }
    });
    /*ResponsiveUIManager+StrictAspectEntry end.*/

    /*StartClickHandler start.*/
    Bridge.define("StartClickHandler", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IPointerDownHandler],
        alias: ["OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown"],
        methods: {
            /*StartClickHandler.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "StartClickHandler#Start", this ); }


            },
            /*StartClickHandler.Start end.*/

            /*StartClickHandler.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "StartClickHandler#Update", this ); }


            },
            /*StartClickHandler.Update end.*/

            /*StartClickHandler.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "StartClickHandler#OnPointerDown", this ); }

                this.EnableSound();
            },
            /*StartClickHandler.OnPointerDown end.*/

            /*StartClickHandler.EnableSound start.*/
            EnableSound: function () {
if ( TRACE ) { TRACE( "StartClickHandler#EnableSound", this ); }

                this.GetComponent(UnityEngine.UI.Image).raycastTarget = false;
                GameManager.Instance.StartMusic();
                if (UnityEngine.Component.op_Inequality(this.transform.parent, null)) {
                    this.transform.parent.gameObject.SetActive(false);
                }
                this.gameObject.SetActive(false);
                GameManager.Instance.enableSound = true;
            },
            /*StartClickHandler.EnableSound end.*/


        }
    });
    /*StartClickHandler end.*/

    /*TaskManager start.*/
    Bridge.define("TaskManager", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            _taskMap: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TaskManager#init", this ); }

                this._taskMap = new (System.Collections.Generic.Dictionary$2(System.String,UnityEngine.Coroutine)).ctor();
            }
        },
        methods: {
            /*TaskManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TaskManager#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(TaskManager.Instance, null) && UnityEngine.MonoBehaviour.op_Inequality(TaskManager.Instance, this)) {
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                    return;
                }

                TaskManager.Instance = this;
                UnityEngine.Object.DontDestroyOnLoad(this.gameObject);
            },
            /*TaskManager.Awake end.*/

            /*TaskManager.CreateSequence start.*/
            CreateSequence: function () {
if ( TRACE ) { TRACE( "TaskManager#CreateSequence", this ); }

                return new TaskSequencePro(this);
            },
            /*TaskManager.CreateSequence end.*/

            /*TaskManager.CreatePooledSequence start.*/
            CreatePooledSequence: function () {
if ( TRACE ) { TRACE( "TaskManager#CreatePooledSequence", this ); }

                var sequence = TaskSequencePool.Shared.Get();
                sequence.Reset();
                return sequence;
            },
            /*TaskManager.CreatePooledSequence end.*/

            /*TaskManager.Run start.*/
            Run: function (routine) {
if ( TRACE ) { TRACE( "TaskManager#Run", this ); }

                if (routine != null) {
                    this.StartCoroutine$1(routine);
                }
            },
            /*TaskManager.Run end.*/

            /*TaskManager.RunTask start.*/
            RunTask: function (id, routine) {
if ( TRACE ) { TRACE( "TaskManager#RunTask", this ); }

                if (System.String.isNullOrEmpty(id) || routine == null) {
                    return;
                }

                this.StopTask(id);
                var coroutine = this.StartCoroutine$1(routine);
                this._taskMap.setItem(id, coroutine);
            },
            /*TaskManager.RunTask end.*/

            /*TaskManager.StopTask start.*/
            StopTask: function (id) {
if ( TRACE ) { TRACE( "TaskManager#StopTask", this ); }

                var coroutine = { };
                if (this._taskMap.tryGetValue(id, coroutine) && coroutine.v != null) {
                    this.StopCoroutine$2(coroutine.v);
                }

                this._taskMap.remove(id);
            },
            /*TaskManager.StopTask end.*/

            /*TaskManager.StopAllTasks start.*/
            StopAllTasks: function () {
if ( TRACE ) { TRACE( "TaskManager#StopAllTasks", this ); }

                var $t;
                $t = Bridge.getEnumerator(this._taskMap.Values);
                try {
                    while ($t.moveNext()) {
                        var coroutine = $t.Current;
                        if (coroutine != null) {
                            this.StopCoroutine$2(coroutine);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this._taskMap.clear();
            },
            /*TaskManager.StopAllTasks end.*/

            /*TaskManager.RunAfter start.*/
            RunAfter: function (delay, action) {
if ( TRACE ) { TRACE( "TaskManager#RunAfter", this ); }

                this.Run(this.DelayRoutine(delay, action));
            },
            /*TaskManager.RunAfter end.*/

            /*TaskManager.RunAfter$1 start.*/
            RunAfter$1: function (T, delay, func, onComplete) {
if ( TRACE ) { TRACE( "TaskManager#RunAfter$1", this ); }

                this.Run(this.RunAfterRoutine(T, delay, func, onComplete));
            },
            /*TaskManager.RunAfter$1 end.*/

            /*TaskManager.RunUntil start.*/
            RunUntil: function (condition, onComplete) {
if ( TRACE ) { TRACE( "TaskManager#RunUntil", this ); }

                this.Run(this.WaitUntilRoutine(condition, onComplete));
            },
            /*TaskManager.RunUntil end.*/

            /*TaskManager.RunWhile start.*/
            RunWhile: function (condition, interval, onTick, onComplete) {
if ( TRACE ) { TRACE( "TaskManager#RunWhile", this ); }

                if (onComplete === void 0) { onComplete = null; }
                this.Run(this.WhileRoutine(condition, interval, onTick, onComplete));
            },
            /*TaskManager.RunWhile end.*/

            /*TaskManager.RunRepeating start.*/
            RunRepeating: function (interval, action, taskId) {
if ( TRACE ) { TRACE( "TaskManager#RunRepeating", this ); }

                if (taskId === void 0) { taskId = null; }
                var loop = this.RepeatingRoutine(interval, action);

                if (!System.String.isNullOrEmpty(taskId)) {
                    this.RunTask(taskId, loop);
                } else {
                    this.Run(loop);
                }
            },
            /*TaskManager.RunRepeating end.*/

            /*TaskManager.DelayRoutine start.*/
            DelayRoutine: function (delay, action) {
if ( TRACE ) { TRACE( "TaskManager#DelayRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(delay);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    !Bridge.staticEquals(action, null) ? action() : null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskManager.DelayRoutine end.*/

            /*TaskManager.RunAfterRoutine start.*/
            RunAfterRoutine: function (T, delay, func, onComplete) {
if ( TRACE ) { TRACE( "TaskManager#RunAfterRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    result,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(delay);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    result = !Bridge.staticEquals(func, null) ? func() : Bridge.getDefaultValue(T);
                                        !Bridge.staticEquals(onComplete, null) ? onComplete(Bridge.rValue(result)) : null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskManager.RunAfterRoutine end.*/

            /*TaskManager.WaitUntilRoutine start.*/
            WaitUntilRoutine: function (condition, onComplete) {
if ( TRACE ) { TRACE( "TaskManager#WaitUntilRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitUntil(condition);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    !Bridge.staticEquals(onComplete, null) ? onComplete() : null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskManager.WaitUntilRoutine end.*/

            /*TaskManager.WhileRoutine start.*/
            WhileRoutine: function (condition, interval, onTick, onComplete) {
if ( TRACE ) { TRACE( "TaskManager#WhileRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( condition() ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    !Bridge.staticEquals(onTick, null) ? onTick() : null;
                                        $enumerator.current = new UnityEngine.WaitForSeconds(interval);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 3: {
                                    !Bridge.staticEquals(onComplete, null) ? onComplete() : null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskManager.WhileRoutine end.*/

            /*TaskManager.RepeatingRoutine start.*/
            RepeatingRoutine: function (interval, action) {
if ( TRACE ) { TRACE( "TaskManager#RepeatingRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 3;
                                        continue;
                                }
                                case 1: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(interval);
                                        $step = 2;
                                        return true;
                                }
                                case 2: {
                                    !Bridge.staticEquals(action, null) ? action() : null;

                                        $step = 0;
                                        continue;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskManager.RepeatingRoutine end.*/


        },
        overloads: {
            "RunAfter(float, Func<T>, Action<T>)": "RunAfter$1"
        }
    });
    /*TaskManager end.*/

    /*TaskSequencePool start.*/
    Bridge.define("TaskSequencePool", {
        statics: {
            fields: {
                Shared: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TaskSequencePool#init", this ); }

                    this.Shared = new TaskSequencePool();
                }
            }
        },
        fields: {
            _pool: null,
            _manager: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TaskSequencePool#init", this ); }

                this._pool = new (System.Collections.Generic.Stack$1(TaskSequencePro)).ctor();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "TaskSequencePool#ctor", this ); }

                this.$initialize();
                this._manager = TaskManager.Instance;
            }
        },
        methods: {
            /*TaskSequencePool.Get start.*/
            Get: function () {
if ( TRACE ) { TRACE( "TaskSequencePool#Get", this ); }

                var sequence;

                if (this._pool.Count > 0) {
                    sequence = this._pool.Pop();
                } else {
                    sequence = new TaskSequencePro(this._manager);
                }

                sequence.Pool = this;
                return sequence;
            },
            /*TaskSequencePool.Get end.*/

            /*TaskSequencePool.Return start.*/
            Return: function (sequence) {
if ( TRACE ) { TRACE( "TaskSequencePool#Return", this ); }

                sequence.Reset(); // Ensure clean state
                sequence.Pool = null;
                this._pool.Push(sequence);
            },
            /*TaskSequencePool.Return end.*/


        }
    });
    /*TaskSequencePool end.*/

    /*TaskSequencePro start.*/
    Bridge.define("TaskSequencePro", {
        fields: {
            _manager: null,
            _steps: null,
            _onComplete: null,
            _onCancel: null,
            _isRunning: false,
            _isPaused: false,
            _isCancelled: false,
            _isCompleted: false,
            _hasStarted: false,
            _currentRoutine: null,
            Pool: null
        },
        props: {
            CoroutineHost: {
                get: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#CoroutineHost#get", this ); }

                    return TaskManager.Instance;
                }
            },
            IsRunning: {
                get: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#IsRunning#get", this ); }

                    return this._isRunning;
                }
            },
            IsPaused: {
                get: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#IsPaused#get", this ); }

                    return this._isPaused;
                }
            },
            IsCancelled: {
                get: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#IsCancelled#get", this ); }

                    return this._isCancelled;
                }
            },
            IsCompleted: {
                get: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#IsCompleted#get", this ); }

                    return this._isCompleted;
                }
            },
            HasStarted: {
                get: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#HasStarted#get", this ); }

                    return this._hasStarted;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#init", this ); }

                this._steps = new (System.Collections.Generic.Queue$1(System.Collections.IEnumerator)).ctor();
            },
            ctor: function (manager) {
if ( TRACE ) { TRACE( "TaskSequencePro#ctor", this ); }

                this.$initialize();
                this._manager = manager;
            }
        },
        methods: {
            /*TaskSequencePro.Append start.*/
            Append: function (action) {
if ( TRACE ) { TRACE( "TaskSequencePro#Append", this ); }

                this._steps.Enqueue(this.ActionRoutine(action));
                return this;
            },
            /*TaskSequencePro.Append end.*/

            /*TaskSequencePro.AppendDelayRealtime start.*/
            AppendDelayRealtime: function (delay) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendDelayRealtime", this ); }

                this._steps.Enqueue(this.DelayRealtimeRoutine(delay));
                return this;
            },
            /*TaskSequencePro.AppendDelayRealtime end.*/

            /*TaskSequencePro.DelayRealtimeRoutine start.*/
            DelayRealtimeRoutine: function (delay) {
if ( TRACE ) { TRACE( "TaskSequencePro#DelayRealtimeRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSecondsRealtime(delay);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.DelayRealtimeRoutine end.*/

            /*TaskSequencePro.AppendWaitForFixedUpdate start.*/
            AppendWaitForFixedUpdate: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendWaitForFixedUpdate", this ); }

                this._steps.Enqueue(this.WaitForFixedUpdateRoutine());
                return this;
            },
            /*TaskSequencePro.AppendWaitForFixedUpdate end.*/

            /*TaskSequencePro.WaitForFixedUpdateRoutine start.*/
            WaitForFixedUpdateRoutine: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#WaitForFixedUpdateRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForFixedUpdate();
                                        $step = 1;
                                        return true;
                                }
                                case 1: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.WaitForFixedUpdateRoutine end.*/

            /*TaskSequencePro.AppendWaitForEndOfFrame start.*/
            AppendWaitForEndOfFrame: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendWaitForEndOfFrame", this ); }

                this._steps.Enqueue(this.WaitForEndOfFrameRoutine());
                return this;
            },
            /*TaskSequencePro.AppendWaitForEndOfFrame end.*/

            /*TaskSequencePro.WaitForEndOfFrameRoutine start.*/
            WaitForEndOfFrameRoutine: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#WaitForEndOfFrameRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForEndOfFrame();
                                        $step = 1;
                                        return true;
                                }
                                case 1: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.WaitForEndOfFrameRoutine end.*/

            /*TaskSequencePro.AppendCallback start.*/
            AppendCallback: function (callback) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendCallback", this ); }

                return this.Append(callback);
            },
            /*TaskSequencePro.AppendCallback end.*/

            /*TaskSequencePro.AppendDelay start.*/
            AppendDelay: function (delay) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendDelay", this ); }

                this._steps.Enqueue(this.DelayRoutine(delay));
                return this;
            },
            /*TaskSequencePro.AppendDelay end.*/

            /*TaskSequencePro.AppendWaitUntil start.*/
            AppendWaitUntil: function (condition) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendWaitUntil", this ); }

                this._steps.Enqueue(this.WaitUntilRoutine(condition));
                return this;
            },
            /*TaskSequencePro.AppendWaitUntil end.*/

            /*TaskSequencePro.AppendWaitWhile start.*/
            AppendWaitWhile: function (condition) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendWaitWhile", this ); }

                this._steps.Enqueue(this.WaitWhileRoutine(condition));
                return this;
            },
            /*TaskSequencePro.AppendWaitWhile end.*/

            /*TaskSequencePro.AppendRoutine start.*/
            AppendRoutine: function (routine) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendRoutine", this ); }

                this._steps.Enqueue(routine);
                return this;
            },
            /*TaskSequencePro.AppendRoutine end.*/

            /*TaskSequencePro.AppendTween start.*/
            AppendTween: function (tween) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendTween", this ); }

                return this.AppendRoutine(this.WaitForTween(tween));
            },
            /*TaskSequencePro.AppendTween end.*/

            /*TaskSequencePro.AppendParallel$1 start.*/
            AppendParallel$1: function (routines) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendParallel$1", this ); }

                if (routines === void 0) { routines = []; }
                this._steps.Enqueue(this.RunParallelRoutines(routines));
                return this;
            },
            /*TaskSequencePro.AppendParallel$1 end.*/

            /*TaskSequencePro.AppendParallel start.*/
            AppendParallel: function (actions) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendParallel", this ); }

                if (actions === void 0) { actions = []; }
                var routines = System.Array.init(actions.length, null, System.Collections.IEnumerator);
                for (var i = 0; i < actions.length; i = (i + 1) | 0) {
                    routines[i] = this.ActionRoutine(actions[i]);
                }
                return this.AppendParallel$1(routines);
            },
            /*TaskSequencePro.AppendParallel end.*/

            /*TaskSequencePro.AppendParallelTweens start.*/
            AppendParallelTweens: function (tweens) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendParallelTweens", this ); }

                if (tweens === void 0) { tweens = []; }
                var routines = System.Array.init(tweens.length, null, System.Collections.IEnumerator);
                for (var i = 0; i < tweens.length; i = (i + 1) | 0) {
                    routines[i] = this.WaitForTween(tweens[i]);
                }
                return this.AppendParallel$1(routines);
            },
            /*TaskSequencePro.AppendParallelTweens end.*/

            /*TaskSequencePro.AppendRepeat start.*/
            AppendRepeat: function (count, action, interval) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendRepeat", this ); }

                if (interval === void 0) { interval = 0.0; }
                this._steps.Enqueue(this.RepeatRoutine(count, action, interval));
                return this;
            },
            /*TaskSequencePro.AppendRepeat end.*/

            /*TaskSequencePro.AppendCondition start.*/
            AppendCondition: function (conditionRoutine) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendCondition", this ); }

                this._steps.Enqueue(conditionRoutine());
                return this;
            },
            /*TaskSequencePro.AppendCondition end.*/

            /*TaskSequencePro.AppendIf start.*/
            AppendIf: function (condition, action) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendIf", this ); }

                if (condition) {
                    this.Append(action);
                }
                return this;
            },
            /*TaskSequencePro.AppendIf end.*/

            /*TaskSequencePro.AppendDelayIf start.*/
            AppendDelayIf: function (condition, delay) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendDelayIf", this ); }

                if (condition) {
                    this.AppendDelay(delay);
                }
                return this;
            },
            /*TaskSequencePro.AppendDelayIf end.*/

            /*TaskSequencePro.AppendTweenIf start.*/
            AppendTweenIf: function (condition, tween) {
if ( TRACE ) { TRACE( "TaskSequencePro#AppendTweenIf", this ); }

                if (condition) {
                    this.AppendTween(tween);
                }
                return this;
            },
            /*TaskSequencePro.AppendTweenIf end.*/

            /*TaskSequencePro.OnComplete start.*/
            OnComplete: function (callback) {
if ( TRACE ) { TRACE( "TaskSequencePro#OnComplete", this ); }

                this._onComplete = callback;
                return this;
            },
            /*TaskSequencePro.OnComplete end.*/

            /*TaskSequencePro.OnCancel start.*/
            OnCancel: function (callback) {
if ( TRACE ) { TRACE( "TaskSequencePro#OnCancel", this ); }

                this._onCancel = callback;
                return this;
            },
            /*TaskSequencePro.OnCancel end.*/

            /*TaskSequencePro.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#Start", this ); }

                if (this._isRunning || this._hasStarted) {
                    return this;
                }

                this._isRunning = true;
                this._hasStarted = true;
                this._isCompleted = false;
                this._currentRoutine = this.CoroutineHost.StartCoroutine$1(this.RunSequence());
                return this;
            },
            /*TaskSequencePro.Start end.*/

            /*TaskSequencePro.Cancel start.*/
            Cancel: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#Cancel", this ); }

                if (!this._isRunning) {
                    return;
                }

                this._isCancelled = true;
                this._isRunning = false;

                if (this._currentRoutine != null) {
                    this.CoroutineHost.StopCoroutine$2(this._currentRoutine);
                    this._currentRoutine = null;
                }

                !Bridge.staticEquals(this._onCancel, null) ? this._onCancel() : null;
                this.ReturnToPoolIfNeeded();
            },
            /*TaskSequencePro.Cancel end.*/

            /*TaskSequencePro.Pause start.*/
            Pause: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#Pause", this ); }

                this._isPaused = true;
            },
            /*TaskSequencePro.Pause end.*/

            /*TaskSequencePro.Resume start.*/
            Resume: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#Resume", this ); }

                this._isPaused = false;
            },
            /*TaskSequencePro.Resume end.*/

            /*TaskSequencePro.Restart start.*/
            Restart: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#Restart", this ); }

                this.Cancel();
                this.Reset();
                this.Start();
                return this;
            },
            /*TaskSequencePro.Restart end.*/

            /*TaskSequencePro.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#Reset", this ); }

                this._steps.Clear();
                this._onComplete = null;
                this._onCancel = null;
                this._isRunning = false;
                this._isPaused = false;
                this._isCancelled = false;
                this._isCompleted = false;
                this._hasStarted = false;
                this._currentRoutine = null;
                return this;
            },
            /*TaskSequencePro.Reset end.*/

            /*TaskSequencePro.RunSequence start.*/
            RunSequence: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#RunSequence", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    step,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( this._steps.Count > 0 ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 9;
                                        continue;
                                }
                                case 1: {
                                    step = this._steps.Dequeue();
                                    $step = 2;
                                    continue;
                                }
                                case 2: {
                                    if ( this._isPaused ) {
                                            $step = 3;
                                            continue;
                                        } 
                                        $step = 5;
                                        continue;
                                }
                                case 3: {
                                    $enumerator.current = null;
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    
                                        $step = 2;
                                        continue;
                                }
                                case 5: {
                                    $enumerator.current = this.CoroutineHost.StartCoroutine$1(step);
                                        $step = 6;
                                        return true;
                                }
                                case 6: {
                                    if (this._isCancelled) {
                                            $step = 7;
                                            continue;
                                        } 
                                        $step = 8;
                                        continue;
                                }
                                case 7: {
                                    return false;
                                }
                                case 8: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 9: {
                                    this.HandleComplete();

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.RunSequence end.*/

            /*TaskSequencePro.HandleComplete start.*/
            HandleComplete: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#HandleComplete", this ); }

                this._isRunning = false;
                this._isCompleted = true;
                !Bridge.staticEquals(this._onComplete, null) ? this._onComplete() : null;
                this.ReturnToPoolIfNeeded();
            },
            /*TaskSequencePro.HandleComplete end.*/

            /*TaskSequencePro.ReturnToPoolIfNeeded start.*/
            ReturnToPoolIfNeeded: function () {
if ( TRACE ) { TRACE( "TaskSequencePro#ReturnToPoolIfNeeded", this ); }

                var $t;
                ($t = this.Pool) != null ? $t.Return(this) : null;
            },
            /*TaskSequencePro.ReturnToPoolIfNeeded end.*/

            /*TaskSequencePro.ActionRoutine start.*/
            ActionRoutine: function (action) {
if ( TRACE ) { TRACE( "TaskSequencePro#ActionRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    !Bridge.staticEquals(action, null) ? action() : null;
                                        $enumerator.current = null;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.ActionRoutine end.*/

            /*TaskSequencePro.DelayRoutine start.*/
            DelayRoutine: function (delay) {
if ( TRACE ) { TRACE( "TaskSequencePro#DelayRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(delay);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.DelayRoutine end.*/

            /*TaskSequencePro.WaitUntilRoutine start.*/
            WaitUntilRoutine: function (condition) {
if ( TRACE ) { TRACE( "TaskSequencePro#WaitUntilRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitUntil(condition);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.WaitUntilRoutine end.*/

            /*TaskSequencePro.WaitWhileRoutine start.*/
            WaitWhileRoutine: function (condition) {
if ( TRACE ) { TRACE( "TaskSequencePro#WaitWhileRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitWhile(condition);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.WaitWhileRoutine end.*/

            /*TaskSequencePro.WaitForTween start.*/
            WaitForTween: function (tween) {
if ( TRACE ) { TRACE( "TaskSequencePro#WaitForTween", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if (tween == null) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 2;
                                        continue;
                                }
                                case 1: {
                                    return false;
                                }
                                case 2: {
                                    DG.Tweening.TweenExtensions.Play(DG.Tweening.Tween, tween);
                                        $enumerator.current = DG.Tweening.TweenExtensions.WaitForCompletion(tween);
                                        $step = 3;
                                        return true;
                                }
                                case 3: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.WaitForTween end.*/

            /*TaskSequencePro.RunParallelRoutines start.*/
            RunParallelRoutines: function (routines) {
if ( TRACE ) { TRACE( "TaskSequencePro#RunParallelRoutines", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    completed,
                    $t,
                    r,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    completed = 0;

                                        $t = Bridge.getEnumerator(routines);
                                        try {
                                            while ($t.moveNext()) {
                                                r = $t.Current;
                                                this.CoroutineHost.StartCoroutine$1(this.RunAndTrack(r, function () {
                                                    Bridge.identity(completed, ((completed = (completed + 1) | 0)));
                                                }));
                                            }
                                        } finally {
                                            if (Bridge.is($t, System.IDisposable)) {
                                                $t.System$IDisposable$Dispose();
                                            }
                                        }

                                        $enumerator.current = new UnityEngine.WaitUntil(function () {
                                            return completed >= routines.length;
                                        });
                                        $step = 1;
                                        return true;
                                }
                                case 1: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.RunParallelRoutines end.*/

            /*TaskSequencePro.RunAndTrack start.*/
            RunAndTrack: function (routine, onComplete) {
if ( TRACE ) { TRACE( "TaskSequencePro#RunAndTrack", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = this.CoroutineHost.StartCoroutine$1(routine);
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    !Bridge.staticEquals(onComplete, null) ? onComplete() : null;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.RunAndTrack end.*/

            /*TaskSequencePro.RepeatRoutine start.*/
            RepeatRoutine: function (count, action, interval) {
if ( TRACE ) { TRACE( "TaskSequencePro#RepeatRoutine", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    i,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    i = 0;
                                        $step = 1;
                                        continue;
                                }
                                case 1: {
                                    if ( i < count ) {
                                            $step = 2;
                                            continue;
                                        }
                                    $step = 9;
                                    continue;
                                }
                                case 2: {
                                    !Bridge.staticEquals(action, null) ? action() : null;
                                        if (interval > 0.0) {
                                            $step = 3;
                                            continue;
                                        } else  {
                                            $step = 5;
                                            continue;
                                        }
                                }
                                case 3: {
                                    $enumerator.current = new UnityEngine.WaitForSeconds(interval);
                                        $step = 4;
                                        return true;
                                }
                                case 4: {
                                    $step = 7;
                                    continue;
                                }
                                case 5: {
                                    $enumerator.current = null;
                                        $step = 6;
                                        return true;
                                }
                                case 6: {
                                    $step = 7;
                                    continue;
                                }
                                case 7: {
                                    $step = 8;
                                    continue;
                                }
                                case 8: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 9: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*TaskSequencePro.RepeatRoutine end.*/


        },
        overloads: {
            "AppendParallel(IEnumerator[])": "AppendParallel$1"
        }
    });
    /*TaskSequencePro end.*/

    /*UIDragger start.*/
    Bridge.define("UIDragger", {
        inherits: [UnityEngine.MonoBehaviour,UnityEngine.EventSystems.IBeginDragHandler,UnityEngine.EventSystems.IDragHandler,UnityEngine.EventSystems.IEndDragHandler],
        fields: {
            rt: null,
            canvas: null,
            startPos: null
        },
        alias: [
            "OnBeginDrag", "UnityEngine$EventSystems$IBeginDragHandler$OnBeginDrag",
            "OnDrag", "UnityEngine$EventSystems$IDragHandler$OnDrag",
            "OnEndDrag", "UnityEngine$EventSystems$IEndDragHandler$OnEndDrag"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "UIDragger#init", this ); }

                this.startPos = new UnityEngine.Vector2();
            }
        },
        methods: {
            /*UIDragger.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "UIDragger#Awake", this ); }

                this.rt = this.GetComponent(UnityEngine.RectTransform);
                this.canvas = this.GetComponentInParent(UnityEngine.Canvas);
            },
            /*UIDragger.Awake end.*/

            /*UIDragger.OnBeginDrag start.*/
            OnBeginDrag: function (e) {
if ( TRACE ) { TRACE( "UIDragger#OnBeginDrag", this ); }

                this.startPos = this.rt.anchoredPosition.$clone();
            },
            /*UIDragger.OnBeginDrag end.*/

            /*UIDragger.OnDrag start.*/
            OnDrag: function (e) {
if ( TRACE ) { TRACE( "UIDragger#OnDrag", this ); }

                if (!UnityEngine.Object.op_Implicit(this.canvas)) {
                    return;
                }
                this.rt.anchoredPosition = this.rt.anchoredPosition.$clone().add( e.delta.$clone().scale( 1.0 / ( this.canvas.scaleFactor ) ) );
            },
            /*UIDragger.OnDrag end.*/

            /*UIDragger.OnEndDrag start.*/
            OnEndDrag: function (e) {
if ( TRACE ) { TRACE( "UIDragger#OnEndDrag", this ); }
 /* optional snap/constraints */
            },
            /*UIDragger.OnEndDrag end.*/


        }
    });
    /*UIDragger end.*/

    /*AudioManager start.*/
    Bridge.define("AudioManager", {
        inherits: [UnityEngine.MonoBehaviour,Core.Services.IAudioService],
        statics: {
            fields: {
                Instance: null
            }
        },
        fields: {
            library: null,
            sfxPoolSize: 0,
            sfxPool: null,
            musicSource: null,
            musicVolume: 0,
            sfxVolume: 0
        },
        alias: [
            "PlaySFX", "Core$Services$IAudioService$PlaySFX",
            "PlayMusic", "Core$Services$IAudioService$PlayMusic",
            "SetMusicVolume", "Core$Services$IAudioService$SetMusicVolume",
            "SetSFXVolume", "Core$Services$IAudioService$SetSFXVolume",
            "StopMusic", "Core$Services$IAudioService$StopMusic"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AudioManager#init", this ); }

                this.sfxPoolSize = 10;
                this.sfxPool = new (System.Collections.Generic.Queue$1(UnityEngine.AudioSource)).ctor();
                this.musicVolume = 1.0;
                this.sfxVolume = 1.0;
            }
        },
        methods: {
            /*AudioManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "AudioManager#Awake", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(AudioManager.Instance, null) && UnityEngine.MonoBehaviour.op_Inequality(AudioManager.Instance, this)) {
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                    return;
                }
                AudioManager.Instance = this;
                UnityEngine.Object.DontDestroyOnLoad(this.gameObject);

                // Create SFX sources
                for (var i = 0; i < this.sfxPoolSize; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor2(System.String.format("SFX_Source_{0}", [Bridge.box(i, System.Int32)]));
                    go.transform.parent = this.transform;
                    var src = go.AddComponent(UnityEngine.AudioSource);
                    src.playOnAwake = false;
                    src.loop = false;
                    src.volume = this.sfxVolume;
                    this.sfxPool.Enqueue(src);
                }

                // Create Music source
                var musicGo = new UnityEngine.GameObject.$ctor2("Music_Source");
                musicGo.transform.parent = this.transform;
                this.musicSource = musicGo.AddComponent(UnityEngine.AudioSource);
                this.musicSource.playOnAwake = false;
                this.musicSource.loop = true;
                this.musicSource.volume = this.musicVolume;

                this.library.Initialize();

                Core.Services.ServicesLocator.Register(Core.Services.IAudioService, this);
            },
            /*AudioManager.Awake end.*/

            /*AudioManager.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "AudioManager#OnDisable", this ); }

                Core.Services.ServicesLocator.Unregister(Core.Services.IAudioService);
            },
            /*AudioManager.OnDisable end.*/

            /*AudioManager.PlaySFX start.*/
            PlaySFX: function (key, position, pitch) {
if ( TRACE ) { TRACE( "AudioManager#PlaySFX", this ); }

                if (position === void 0) { position = null; }
                if (pitch === void 0) { pitch = 1.0; }
                var entry = { v : new AudioLibrary.ClipEntry() };
                if (!this.library.TryGetClip(key, entry) || entry.v.channel !== AudioChannel.SFX) {
                    return;
                }

                if (this.sfxPool.Count === 0) {
                    return;
                } // Avoid overflow

                var src = this.sfxPool.Dequeue();
                src.clip = entry.v.clip;
                src.volume = this.sfxVolume * entry.v.volume;
                src.pitch = pitch;

                src.Play();

                this.StartCoroutine$1(this.ReturnToPoolWhenDone(src));
            },
            /*AudioManager.PlaySFX end.*/

            /*AudioManager.PlayMusic start.*/
            PlayMusic: function (key, fadeDuration) {
if ( TRACE ) { TRACE( "AudioManager#PlayMusic", this ); }

                if (fadeDuration === void 0) { fadeDuration = 0.5; }
                var entry = { v : new AudioLibrary.ClipEntry() };
                if (!this.library.TryGetClip(key, entry) || entry.v.channel !== AudioChannel.Music) {
                    return;
                }

                if (this.musicSource.isPlaying && Bridge.referenceEquals(this.musicSource.clip, entry.v.clip)) {
                    return;
                }

                this.StopCoroutine$1("CrossfadeMusic");
                this.StartCoroutine$1(this.CrossfadeMusic(entry.v.clip, entry.v.volume, entry.v.loop, fadeDuration));
            },
            /*AudioManager.PlayMusic end.*/

            /*AudioManager.StopMusic$1 start.*/
            StopMusic$1: function () {
if ( TRACE ) { TRACE( "AudioManager#StopMusic$1", this ); }

                this.musicSource.Stop();
            },
            /*AudioManager.StopMusic$1 end.*/

            /*AudioManager.StopMusic start.*/
            StopMusic: function (fadeDuration) {
if ( TRACE ) { TRACE( "AudioManager#StopMusic", this ); }

                if (fadeDuration === void 0) { fadeDuration = 1.0; }
                if (UnityEngine.Component.op_Equality(this.musicSource, null) || !this.musicSource.isPlaying) {
                    return;
                }

                this.StartCoroutine$1(this.FadeOutAndStop(this.musicSource, fadeDuration));
            },
            /*AudioManager.StopMusic end.*/

            /*AudioManager.SetMusicVolume start.*/
            SetMusicVolume: function (volume) {
if ( TRACE ) { TRACE( "AudioManager#SetMusicVolume", this ); }

                this.musicVolume = Math.max(0, Math.min(1, volume));
                this.musicSource.volume = this.musicVolume;
            },
            /*AudioManager.SetMusicVolume end.*/

            /*AudioManager.SetSFXVolume start.*/
            SetSFXVolume: function (volume) {
if ( TRACE ) { TRACE( "AudioManager#SetSFXVolume", this ); }

                this.sfxVolume = Math.max(0, Math.min(1, volume));
            },
            /*AudioManager.SetSFXVolume end.*/

            /*AudioManager.ReturnToPoolWhenDone start.*/
            ReturnToPoolWhenDone: function (src) {
if ( TRACE ) { TRACE( "AudioManager#ReturnToPoolWhenDone", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = new UnityEngine.WaitWhile(function () {
                                            return src.isPlaying;
                                        });
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    this.sfxPool.Enqueue(src);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*AudioManager.ReturnToPoolWhenDone end.*/

            /*AudioManager.CrossfadeMusic start.*/
            CrossfadeMusic: function (newClip, targetVolume, loop, duration) {
if ( TRACE ) { TRACE( "AudioManager#CrossfadeMusic", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    startVolume,
                    t,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    startVolume = this.musicSource.volume;
                                        t = 0.0;

                                        // Fade out
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( t < duration ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    t += UnityEngine.Time.deltaTime;
                                        this.musicSource.volume = pc.math.lerp(startVolume, 0.0, t / duration);
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    this.musicSource.Stop();
                                        this.musicSource.clip = newClip;
                                        this.musicSource.loop = loop;
                                        this.musicSource.Play();

                                        // Fade in
                                        t = 0.0;
                                    $step = 5;
                                    continue;
                                }
                                case 5: {
                                    if ( t < duration ) {
                                            $step = 6;
                                            continue;
                                        } 
                                        $step = 8;
                                        continue;
                                }
                                case 6: {
                                    t += UnityEngine.Time.deltaTime;
                                        this.musicSource.volume = pc.math.lerp(0.0, targetVolume, t / duration);
                                        $enumerator.current = null;
                                        $step = 7;
                                        return true;
                                }
                                case 7: {
                                    
                                        $step = 5;
                                        continue;
                                }
                                case 8: {
                                    this.musicSource.volume = targetVolume;

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*AudioManager.CrossfadeMusic end.*/

            /*AudioManager.FadeOutAndStop start.*/
            FadeOutAndStop: function (source, duration) {
if ( TRACE ) { TRACE( "AudioManager#FadeOutAndStop", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    startVolume,
                    time,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    startVolume = source.volume;

                                        time = 0.0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( time < duration ) {
                                            $step = 2;
                                            continue;
                                        } 
                                        $step = 4;
                                        continue;
                                }
                                case 2: {
                                    time += UnityEngine.Time.deltaTime;
                                        source.volume = pc.math.lerp(startVolume, 0.0, time / duration);
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    
                                        $step = 1;
                                        continue;
                                }
                                case 4: {
                                    source.Stop();
                                        source.volume = startVolume; // Reset volume in case it's reused

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*AudioManager.FadeOutAndStop end.*/


        },
        overloads: {
            "StopMusic()": "StopMusic$1"
        }
    });
    /*AudioManager end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","System.Collections.Generic","UnityEngine","System.Collections","DG.Tweening","UnityEngine.EventSystems","UnityEngine.UI","DG.Tweening.Core","System.Globalization","DG.Tweening.Plugins.Core.PathCore","DG.Tweening.Plugins.Options"];

    /*AudioChannel start.*/
    $m("AudioChannel", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Music","is":true,"t":4,"rt":AudioChannel,"sn":"Music","box":function ($v) { return Bridge.box($v, AudioChannel, System.Enum.toStringFn(AudioChannel));}},{"a":2,"n":"SFX","is":true,"t":4,"rt":AudioChannel,"sn":"SFX","box":function ($v) { return Bridge.box($v, AudioChannel, System.Enum.toStringFn(AudioChannel));}}]}; }, $n);
    /*AudioChannel end.*/

    /*AudioLibrary start.*/
    $m("AudioLibrary", function () { return {"nested":[AudioLibrary.ClipEntry],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Audio/Audio Library", fileName: "AudioLibrary"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"TryGetClip","t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"entry","out":true,"pt":AudioLibrary.ClipEntry,"ps":1}],"sn":"TryGetClip","rt":$n[0].Boolean,"p":[$n[0].String,AudioLibrary.ClipEntry],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clips","t":4,"rt":$n[1].List$1(AudioLibrary.ClipEntry),"sn":"clips"},{"a":1,"n":"lookup","t":4,"rt":$n[1].Dictionary$2(System.String,AudioLibrary.ClipEntry),"sn":"lookup"}]}; }, $n);
    /*AudioLibrary end.*/

    /*AudioLibrary+ClipEntry start.*/
    $m("AudioLibrary.ClipEntry", function () { return {"td":AudioLibrary,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"channel","t":4,"rt":AudioChannel,"sn":"channel","box":function ($v) { return Bridge.box($v, AudioChannel, System.Enum.toStringFn(AudioChannel));}},{"a":2,"n":"clip","t":4,"rt":$n[2].AudioClip,"sn":"clip"},{"a":2,"n":"key","t":4,"rt":$n[0].String,"sn":"key"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"volume","t":4,"rt":$n[0].Single,"sn":"volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*AudioLibrary+ClipEntry end.*/

    /*AudioManager start.*/
    $m("AudioManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"CrossfadeMusic","t":8,"pi":[{"n":"newClip","pt":$n[2].AudioClip,"ps":0},{"n":"targetVolume","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"CrossfadeMusic","rt":$n[3].IEnumerator,"p":[$n[2].AudioClip,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"FadeOutAndStop","t":8,"pi":[{"n":"source","pt":$n[2].AudioSource,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1}],"sn":"FadeOutAndStop","rt":$n[3].IEnumerator,"p":[$n[2].AudioSource,$n[0].Single]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"PlayMusic","t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"fadeDuration","dv":0.5,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"PlayMusic","rt":$n[0].Void,"p":[$n[0].String,$n[0].Single]},{"a":2,"n":"PlaySFX","t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"position","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Vector3),"ps":1},{"n":"pitch","dv":1.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"PlaySFX","rt":$n[0].Void,"p":[$n[0].String,$n[0].Nullable$1(UnityEngine.Vector3),$n[0].Single]},{"a":1,"n":"ReturnToPoolWhenDone","t":8,"pi":[{"n":"src","pt":$n[2].AudioSource,"ps":0}],"sn":"ReturnToPoolWhenDone","rt":$n[3].IEnumerator,"p":[$n[2].AudioSource]},{"a":2,"n":"SetMusicVolume","t":8,"pi":[{"n":"volume","pt":$n[0].Single,"ps":0}],"sn":"SetMusicVolume","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"SetSFXVolume","t":8,"pi":[{"n":"volume","pt":$n[0].Single,"ps":0}],"sn":"SetSFXVolume","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"StopMusic","t":8,"sn":"StopMusic$1","rt":$n[0].Void},{"a":2,"n":"StopMusic","t":8,"pi":[{"n":"fadeDuration","dv":1.0,"o":true,"pt":$n[0].Single,"ps":0}],"sn":"StopMusic","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"Instance","is":true,"t":16,"rt":AudioManager,"g":{"a":2,"n":"get_Instance","t":8,"rt":AudioManager,"fg":"Instance","is":true},"s":{"a":1,"n":"set_Instance","t":8,"p":[AudioManager],"rt":$n[0].Void,"fs":"Instance","is":true},"fn":"Instance"},{"at":[new UnityEngine.HeaderAttribute("Library")],"a":2,"n":"library","t":4,"rt":AudioLibrary,"sn":"library"},{"a":1,"n":"musicSource","t":4,"rt":$n[2].AudioSource,"sn":"musicSource"},{"a":1,"n":"musicVolume","t":4,"rt":$n[0].Single,"sn":"musicVolume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"sfxPool","t":4,"rt":$n[1].Queue$1(UnityEngine.AudioSource),"sn":"sfxPool"},{"at":[new UnityEngine.HeaderAttribute("SFX Pool Settings")],"a":2,"n":"sfxPoolSize","t":4,"rt":$n[0].Int32,"sn":"sfxPoolSize","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"sfxVolume","t":4,"rt":$n[0].Single,"sn":"sfxVolume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<Instance>k__BackingField","is":true,"t":4,"rt":AudioManager,"sn":"Instance"}]}; }, $n);
    /*AudioManager end.*/

    /*ButtonPulse start.*/
    $m("ButtonPulse", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"StartPulse","t":8,"sn":"StartPulse","rt":$n[0].Void},{"a":2,"n":"StopPulse","t":8,"pi":[{"n":"resetScale","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"StopPulse","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"_originalScale","t":4,"rt":$n[2].Vector3,"sn":"_originalScale"},{"a":1,"n":"_pulseTween","t":4,"rt":$n[4].Tween,"sn":"_pulseTween"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pulseDuration","t":4,"rt":$n[0].Single,"sn":"pulseDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Pulse Settings"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scaleMultiplier","t":4,"rt":$n[0].Single,"sn":"scaleMultiplier","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*ButtonPulse end.*/

    /*FluidGridLayout start.*/
    $m("FluidGridLayout", function () { return {"nested":[FluidGridLayout.FitAxis,FluidGridLayout.OverflowMode,FluidGridLayout.Constraint,FluidGridLayout.OrderMode,FluidGridLayout.HorizontalDir,FluidGridLayout.VerticalDir,FluidGridLayout.HAlign,FluidGridLayout.VAlign],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyChildrenLayout","t":8,"sn":"ApplyChildrenLayout","rt":$n[0].Void},{"ov":true,"a":2,"n":"CalculateLayoutInputHorizontal","t":8,"sn":"CalculateLayoutInputHorizontal","rt":$n[0].Void},{"ov":true,"a":2,"n":"CalculateLayoutInputVertical","t":8,"sn":"CalculateLayoutInputVertical","rt":$n[0].Void},{"a":1,"n":"ComputeLayout","t":8,"sn":"ComputeLayout","rt":$n[0].Void},{"a":1,"n":"GetActiveChildCount","t":8,"sn":"GetActiveChildCount","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnRectTransformDimensionsChange","t":8,"sn":"OnRectTransformDimensionsChange","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnTransformChildrenChanged","t":8,"sn":"OnTransformChildrenChanged","rt":$n[0].Void},{"a":3,"n":"SetDirty","t":8,"sn":"SetDirty$1","rt":$n[0].Void},{"ov":true,"a":2,"n":"SetLayoutHorizontal","t":8,"sn":"SetLayoutHorizontal","rt":$n[0].Void},{"ov":true,"a":2,"n":"SetLayoutVertical","t":8,"sn":"SetLayoutVertical","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute(),new ReadOnlyAttribute()],"a":1,"n":"_chosenCell","t":4,"rt":$n[2].Vector2,"sn":"_chosenCell"},{"at":[new UnityEngine.HeaderAttribute("Debug (read-only)"),new UnityEngine.SerializeFieldAttribute(),new ReadOnlyAttribute()],"a":1,"n":"_chosenColumns","t":4,"rt":$n[0].Int32,"sn":"_chosenColumns","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new ReadOnlyAttribute()],"a":1,"n":"_chosenRows","t":4,"rt":$n[0].Int32,"sn":"_chosenRows","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("Aspect ratio W/H when enforceAspect = true.")],"a":2,"n":"aspectWH","t":4,"rt":$n[0].Single,"sn":"aspectWH","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Automatically rebuild layout when children are added/removed/enabled/disabled.")],"a":2,"n":"autoRebuildOnChildChange","t":4,"rt":$n[0].Boolean,"sn":"autoRebuildOnChildChange","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Convenience toggles to center along an axis (applied after Start alignment).")],"a":2,"n":"centerX","t":4,"rt":$n[0].Boolean,"sn":"centerX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"centerY","t":4,"rt":$n[0].Boolean,"sn":"centerY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("When Constraint=None, grid will try from min..max columns and pick best.")],"a":2,"n":"columnsRange","t":4,"rt":$n[2].Vector2Int,"sn":"columnsRange"},{"at":[new UnityEngine.TooltipAttribute("Choose how columns/rows are determined.")],"a":2,"n":"constraint","t":4,"rt":FluidGridLayout.Constraint,"sn":"constraint","box":function ($v) { return Bridge.box($v, FluidGridLayout.Constraint, System.Enum.toStringFn(FluidGridLayout.Constraint));}},{"at":[new UnityEngine.TooltipAttribute("Used when Constraint = FixedColumns or FixedRows.")],"a":2,"n":"constraintCount","t":4,"rt":$n[0].Int32,"sn":"constraintCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("If true (and not keepSquare), enforces given aspect W/H.")],"a":2,"n":"enforceAspect","t":4,"rt":$n[0].Boolean,"sn":"enforceAspect","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("If > 0, only consider column counts that are multiples of this (symmetry). 0 = ignore.")],"a":2,"n":"evenness","t":4,"rt":$n[0].Int32,"sn":"evenness","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.HeaderAttribute("Grid Fit")],"a":2,"n":"fitAxis","t":4,"rt":FluidGridLayout.FitAxis,"sn":"fitAxis","box":function ($v) { return Bridge.box($v, FluidGridLayout.FitAxis, System.Enum.toStringFn(FluidGridLayout.FitAxis));}},{"at":[new UnityEngine.TooltipAttribute("Horizontal alignment of the laid-out block within the parent's padded area.")],"a":2,"n":"horizontalAlign","t":4,"rt":FluidGridLayout.HAlign,"sn":"horizontalAlign","box":function ($v) { return Bridge.box($v, FluidGridLayout.HAlign, System.Enum.toStringFn(FluidGridLayout.HAlign));}},{"a":2,"n":"horizontalDirection","t":4,"rt":FluidGridLayout.HorizontalDir,"sn":"horizontalDirection","box":function ($v) { return Bridge.box($v, FluidGridLayout.HorizontalDir, System.Enum.toStringFn(FluidGridLayout.HorizontalDir));}},{"at":[new UnityEngine.HeaderAttribute("Cell Sizing"),new UnityEngine.TooltipAttribute("If true, forces a square cell (W=H).")],"a":2,"n":"keepSquare","t":4,"rt":$n[0].Boolean,"sn":"keepSquare","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"maxCell","t":4,"rt":$n[2].Vector2,"sn":"maxCell"},{"a":2,"n":"minCell","t":4,"rt":$n[2].Vector2,"sn":"minCell"},{"at":[new UnityEngine.HeaderAttribute("Order & Direction")],"a":2,"n":"order","t":4,"rt":FluidGridLayout.OrderMode,"sn":"order","box":function ($v) { return Bridge.box($v, FluidGridLayout.OrderMode, System.Enum.toStringFn(FluidGridLayout.OrderMode));}},{"a":2,"n":"overflow","t":4,"rt":FluidGridLayout.OverflowMode,"sn":"overflow","box":function ($v) { return Bridge.box($v, FluidGridLayout.OverflowMode, System.Enum.toStringFn(FluidGridLayout.OverflowMode));}},{"at":[new UnityEngine.HeaderAttribute("Child Control"),new UnityEngine.TooltipAttribute("If false, children keep their size; grid only positions them. If true, grid sets their size to cell.")],"a":2,"n":"overrideChildSize","t":4,"rt":$n[0].Boolean,"sn":"overrideChildSize","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("When shrinking to fit, preserve square/fixed aspect (recommended).")],"a":2,"n":"preserveAspectOnScaleDown","t":4,"rt":$n[0].Boolean,"sn":"preserveAspectOnScaleDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("No-Overflow (ScaleDownToFit)"),new UnityEngine.TooltipAttribute("If true, while shrinking to fit, will not go below minCell.")],"a":2,"n":"respectMinCellOnScaleDown","t":4,"rt":$n[0].Boolean,"sn":"respectMinCellOnScaleDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Reverse the final child order after direction/order are applied.")],"a":2,"n":"reverseOrder","t":4,"rt":$n[0].Boolean,"sn":"reverseOrder","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Quality"),new UnityEngine.TooltipAttribute("Round positions/sizes to whole pixels to avoid blurriness.")],"a":2,"n":"snapToPixels","t":4,"rt":$n[0].Boolean,"sn":"snapToPixels","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Spacing & Alignment")],"a":2,"n":"spacing","t":4,"rt":$n[2].Vector2,"sn":"spacing"},{"at":[new UnityEngine.TooltipAttribute("Vertical alignment of the laid-out block within the parent's padded area.")],"a":2,"n":"verticalAlign","t":4,"rt":FluidGridLayout.VAlign,"sn":"verticalAlign","box":function ($v) { return Bridge.box($v, FluidGridLayout.VAlign, System.Enum.toStringFn(FluidGridLayout.VAlign));}},{"a":2,"n":"verticalDirection","t":4,"rt":FluidGridLayout.VerticalDir,"sn":"verticalDirection","box":function ($v) { return Bridge.box($v, FluidGridLayout.VerticalDir, System.Enum.toStringFn(FluidGridLayout.VerticalDir));}}]}; }, $n);
    /*FluidGridLayout end.*/

    /*FluidGridLayout+FitAxis start.*/
    $m("FluidGridLayout.FitAxis", function () { return {"td":FluidGridLayout,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Both","is":true,"t":4,"rt":FluidGridLayout.FitAxis,"sn":"Both","box":function ($v) { return Bridge.box($v, FluidGridLayout.FitAxis, System.Enum.toStringFn(FluidGridLayout.FitAxis));}},{"a":2,"n":"HorizontalOnly","is":true,"t":4,"rt":FluidGridLayout.FitAxis,"sn":"HorizontalOnly","box":function ($v) { return Bridge.box($v, FluidGridLayout.FitAxis, System.Enum.toStringFn(FluidGridLayout.FitAxis));}},{"a":2,"n":"VerticalOnly","is":true,"t":4,"rt":FluidGridLayout.FitAxis,"sn":"VerticalOnly","box":function ($v) { return Bridge.box($v, FluidGridLayout.FitAxis, System.Enum.toStringFn(FluidGridLayout.FitAxis));}}]}; }, $n);
    /*FluidGridLayout+FitAxis end.*/

    /*FluidGridLayout+OverflowMode start.*/
    $m("FluidGridLayout.OverflowMode", function () { return {"td":FluidGridLayout,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AllowVerticalScroll","is":true,"t":4,"rt":FluidGridLayout.OverflowMode,"sn":"AllowVerticalScroll","box":function ($v) { return Bridge.box($v, FluidGridLayout.OverflowMode, System.Enum.toStringFn(FluidGridLayout.OverflowMode));}},{"a":2,"n":"ClampToParent","is":true,"t":4,"rt":FluidGridLayout.OverflowMode,"sn":"ClampToParent","box":function ($v) { return Bridge.box($v, FluidGridLayout.OverflowMode, System.Enum.toStringFn(FluidGridLayout.OverflowMode));}},{"a":2,"n":"ScaleDownToFit","is":true,"t":4,"rt":FluidGridLayout.OverflowMode,"sn":"ScaleDownToFit","box":function ($v) { return Bridge.box($v, FluidGridLayout.OverflowMode, System.Enum.toStringFn(FluidGridLayout.OverflowMode));}}]}; }, $n);
    /*FluidGridLayout+OverflowMode end.*/

    /*FluidGridLayout+Constraint start.*/
    $m("FluidGridLayout.Constraint", function () { return {"td":FluidGridLayout,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"FixedColumns","is":true,"t":4,"rt":FluidGridLayout.Constraint,"sn":"FixedColumns","box":function ($v) { return Bridge.box($v, FluidGridLayout.Constraint, System.Enum.toStringFn(FluidGridLayout.Constraint));}},{"a":2,"n":"FixedRows","is":true,"t":4,"rt":FluidGridLayout.Constraint,"sn":"FixedRows","box":function ($v) { return Bridge.box($v, FluidGridLayout.Constraint, System.Enum.toStringFn(FluidGridLayout.Constraint));}},{"a":2,"n":"None","is":true,"t":4,"rt":FluidGridLayout.Constraint,"sn":"None","box":function ($v) { return Bridge.box($v, FluidGridLayout.Constraint, System.Enum.toStringFn(FluidGridLayout.Constraint));}}]}; }, $n);
    /*FluidGridLayout+Constraint end.*/

    /*FluidGridLayout+OrderMode start.*/
    $m("FluidGridLayout.OrderMode", function () { return {"td":FluidGridLayout,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ColumnMajor","is":true,"t":4,"rt":FluidGridLayout.OrderMode,"sn":"ColumnMajor","box":function ($v) { return Bridge.box($v, FluidGridLayout.OrderMode, System.Enum.toStringFn(FluidGridLayout.OrderMode));}},{"a":2,"n":"RowMajor","is":true,"t":4,"rt":FluidGridLayout.OrderMode,"sn":"RowMajor","box":function ($v) { return Bridge.box($v, FluidGridLayout.OrderMode, System.Enum.toStringFn(FluidGridLayout.OrderMode));}}]}; }, $n);
    /*FluidGridLayout+OrderMode end.*/

    /*FluidGridLayout+HorizontalDir start.*/
    $m("FluidGridLayout.HorizontalDir", function () { return {"td":FluidGridLayout,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"LeftToRight","is":true,"t":4,"rt":FluidGridLayout.HorizontalDir,"sn":"LeftToRight","box":function ($v) { return Bridge.box($v, FluidGridLayout.HorizontalDir, System.Enum.toStringFn(FluidGridLayout.HorizontalDir));}},{"a":2,"n":"RightToLeft","is":true,"t":4,"rt":FluidGridLayout.HorizontalDir,"sn":"RightToLeft","box":function ($v) { return Bridge.box($v, FluidGridLayout.HorizontalDir, System.Enum.toStringFn(FluidGridLayout.HorizontalDir));}}]}; }, $n);
    /*FluidGridLayout+HorizontalDir end.*/

    /*FluidGridLayout+VerticalDir start.*/
    $m("FluidGridLayout.VerticalDir", function () { return {"td":FluidGridLayout,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BottomToTop","is":true,"t":4,"rt":FluidGridLayout.VerticalDir,"sn":"BottomToTop","box":function ($v) { return Bridge.box($v, FluidGridLayout.VerticalDir, System.Enum.toStringFn(FluidGridLayout.VerticalDir));}},{"a":2,"n":"TopToBottom","is":true,"t":4,"rt":FluidGridLayout.VerticalDir,"sn":"TopToBottom","box":function ($v) { return Bridge.box($v, FluidGridLayout.VerticalDir, System.Enum.toStringFn(FluidGridLayout.VerticalDir));}}]}; }, $n);
    /*FluidGridLayout+VerticalDir end.*/

    /*FluidGridLayout+HAlign start.*/
    $m("FluidGridLayout.HAlign", function () { return {"td":FluidGridLayout,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Center","is":true,"t":4,"rt":FluidGridLayout.HAlign,"sn":"Center","box":function ($v) { return Bridge.box($v, FluidGridLayout.HAlign, System.Enum.toStringFn(FluidGridLayout.HAlign));}},{"a":2,"n":"End","is":true,"t":4,"rt":FluidGridLayout.HAlign,"sn":"End","box":function ($v) { return Bridge.box($v, FluidGridLayout.HAlign, System.Enum.toStringFn(FluidGridLayout.HAlign));}},{"a":2,"n":"Justify","is":true,"t":4,"rt":FluidGridLayout.HAlign,"sn":"Justify","box":function ($v) { return Bridge.box($v, FluidGridLayout.HAlign, System.Enum.toStringFn(FluidGridLayout.HAlign));}},{"a":2,"n":"Start","is":true,"t":4,"rt":FluidGridLayout.HAlign,"sn":"Start","box":function ($v) { return Bridge.box($v, FluidGridLayout.HAlign, System.Enum.toStringFn(FluidGridLayout.HAlign));}}]}; }, $n);
    /*FluidGridLayout+HAlign end.*/

    /*FluidGridLayout+VAlign start.*/
    $m("FluidGridLayout.VAlign", function () { return {"td":FluidGridLayout,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Center","is":true,"t":4,"rt":FluidGridLayout.VAlign,"sn":"Center","box":function ($v) { return Bridge.box($v, FluidGridLayout.VAlign, System.Enum.toStringFn(FluidGridLayout.VAlign));}},{"a":2,"n":"End","is":true,"t":4,"rt":FluidGridLayout.VAlign,"sn":"End","box":function ($v) { return Bridge.box($v, FluidGridLayout.VAlign, System.Enum.toStringFn(FluidGridLayout.VAlign));}},{"a":2,"n":"Justify","is":true,"t":4,"rt":FluidGridLayout.VAlign,"sn":"Justify","box":function ($v) { return Bridge.box($v, FluidGridLayout.VAlign, System.Enum.toStringFn(FluidGridLayout.VAlign));}},{"a":2,"n":"Start","is":true,"t":4,"rt":FluidGridLayout.VAlign,"sn":"Start","box":function ($v) { return Bridge.box($v, FluidGridLayout.VAlign, System.Enum.toStringFn(FluidGridLayout.VAlign));}}]}; }, $n);
    /*FluidGridLayout+VAlign end.*/

    /*ReadOnlyAttribute start.*/
    $m("ReadOnlyAttribute", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*ReadOnlyAttribute end.*/

    /*GameManager start.*/
    $m("GameManager", function () { return {"nested":[GameManager.GameState],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"CTAClicked","t":8,"sn":"CTAClicked","rt":$n[0].Void},{"a":2,"n":"ChangeState","t":8,"pi":[{"n":"newState","pt":GameManager.GameState,"ps":0}],"sn":"ChangeState","rt":$n[0].Void,"p":[GameManager.GameState]},{"a":1,"n":"DestroyHandObj","t":8,"sn":"DestroyHandObj","rt":$n[3].IEnumerator},{"a":2,"n":"RestartGame","t":8,"sn":"RestartGame","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"StartMusic","t":8,"sn":"StartMusic","rt":$n[0].Void},{"a":2,"n":"Win","t":8,"sn":"Win","rt":$n[3].IEnumerator},{"a":2,"n":"CurrentScore","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_CurrentScore","t":8,"rt":$n[0].Int32,"fg":"CurrentScore","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_CurrentScore","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"CurrentScore"},"fn":"CurrentScore"},{"a":2,"n":"CurrentState","t":16,"rt":GameManager.GameState,"g":{"a":2,"n":"get_CurrentState","t":8,"rt":GameManager.GameState,"fg":"CurrentState","box":function ($v) { return Bridge.box($v, GameManager.GameState, System.Enum.toStringFn(GameManager.GameState));}},"s":{"a":1,"n":"set_CurrentState","t":8,"p":[GameManager.GameState],"rt":$n[0].Void,"fs":"CurrentState"},"fn":"CurrentState"},{"a":2,"n":"Instance","is":true,"t":4,"rt":GameManager,"sn":"Instance"},{"a":2,"n":"arrow","t":4,"rt":$n[2].GameObject,"sn":"arrow"},{"a":2,"n":"currentScore","t":4,"rt":$n[0].Int32,"sn":"currentScore","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"enableSound","t":4,"rt":$n[0].Boolean,"sn":"enableSound","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"end","t":4,"rt":$n[0].Boolean,"sn":"end","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"endPanel","t":4,"rt":$n[2].GameObject,"sn":"endPanel"},{"a":2,"n":"hand","t":4,"rt":$n[2].GameObject,"sn":"hand"},{"a":2,"n":"startClickHandler","t":4,"rt":StartClickHandler,"sn":"startClickHandler"},{"a":1,"backing":true,"n":"<CurrentState>k__BackingField","t":4,"rt":GameManager.GameState,"sn":"CurrentState","box":function ($v) { return Bridge.box($v, GameManager.GameState, System.Enum.toStringFn(GameManager.GameState));}}]}; }, $n);
    /*GameManager end.*/

    /*GameManager+GameState start.*/
    $m("GameManager.GameState", function () { return {"td":GameManager,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GameOver","is":true,"t":4,"rt":GameManager.GameState,"sn":"GameOver","box":function ($v) { return Bridge.box($v, GameManager.GameState, System.Enum.toStringFn(GameManager.GameState));}},{"a":2,"n":"MainMenu","is":true,"t":4,"rt":GameManager.GameState,"sn":"MainMenu","box":function ($v) { return Bridge.box($v, GameManager.GameState, System.Enum.toStringFn(GameManager.GameState));}},{"a":2,"n":"Paused","is":true,"t":4,"rt":GameManager.GameState,"sn":"Paused","box":function ($v) { return Bridge.box($v, GameManager.GameState, System.Enum.toStringFn(GameManager.GameState));}},{"a":2,"n":"Playing","is":true,"t":4,"rt":GameManager.GameState,"sn":"Playing","box":function ($v) { return Bridge.box($v, GameManager.GameState, System.Enum.toStringFn(GameManager.GameState));}}]}; }, $n);
    /*GameManager+GameState end.*/

    /*HorizontalUIDragClamp start.*/
    $m("HorizontalUIDragClamp", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"ClampWithinParentHorizontal","t":8,"sn":"ClampWithinParentHorizontal","rt":$n[0].Void},{"a":1,"n":"IsDragValid","t":8,"pi":[{"n":"e","pt":$n[5].PointerEventData,"ps":0}],"sn":"IsDragValid","rt":$n[0].Boolean,"p":[$n[5].PointerEventData],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnBeginDrag","t":8,"pi":[{"n":"eventData","pt":$n[5].PointerEventData,"ps":0}],"sn":"OnBeginDrag","rt":$n[0].Void,"p":[$n[5].PointerEventData]},{"a":2,"n":"OnDrag","t":8,"pi":[{"n":"eventData","pt":$n[5].PointerEventData,"ps":0}],"sn":"OnDrag","rt":$n[0].Void,"p":[$n[5].PointerEventData]},{"a":2,"n":"OnEndDrag","t":8,"pi":[{"n":"eventData","pt":$n[5].PointerEventData,"ps":0}],"sn":"OnEndDrag","rt":$n[0].Void,"p":[$n[5].PointerEventData]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"dragging","t":4,"rt":$n[0].Boolean,"sn":"dragging","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Extra inside padding (pixels) from the parent's left/right edges.")],"a":2,"n":"leftPadding","t":4,"rt":$n[0].Single,"sn":"leftPadding","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"parent","t":4,"rt":$n[2].RectTransform,"sn":"parent"},{"at":[new UnityEngine.TooltipAttribute("Allow dragging when pointer isn't over this element (useful for child graphics).")],"a":2,"n":"requireRaycastTarget","t":4,"rt":$n[0].Boolean,"sn":"requireRaycastTarget","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rightPadding","t":4,"rt":$n[0].Single,"sn":"rightPadding","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"rootCanvas","t":4,"rt":$n[2].Canvas,"sn":"rootCanvas"},{"a":1,"n":"rt","t":4,"rt":$n[2].RectTransform,"sn":"rt"},{"at":[new UnityEngine.HeaderAttribute("Options"),new UnityEngine.TooltipAttribute("If true, movement is smoothed with exponential damping.")],"a":2,"n":"smooth","t":4,"rt":$n[0].Boolean,"sn":"smooth","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(0.01, 30.0)],"a":2,"n":"smoothSpeed","t":4,"rt":$n[0].Single,"sn":"smoothSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"targetAnchoredPos","t":4,"rt":$n[2].Vector2,"sn":"targetAnchoredPos"},{"a":1,"n":"uiCam","t":4,"rt":$n[2].Camera,"sn":"uiCam"}]}; }, $n);
    /*HorizontalUIDragClamp end.*/

    /*OrientationLayoutSwitcher start.*/
    $m("OrientationLayoutSwitcher", function () { return {"att":1048833,"a":2,"at":[new UnityEngine.DisallowMultipleComponent()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplySafe","t":8,"pi":[{"n":"root","pt":$n[2].GameObject,"ps":0}],"sn":"ApplySafe","rt":$n[0].Void,"p":[$n[2].GameObject]},{"a":1,"n":"Handle","t":8,"pi":[{"n":"o","pt":$n[2].ScreenOrientation,"ps":0}],"sn":"Handle","rt":$n[0].Void,"p":[$n[2].ScreenOrientation]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"at":[new UnityEngine.HeaderAttribute("Optional: Safe Area inside these roots")],"a":2,"n":"applySafeAreaToRoots","t":4,"rt":$n[0].Boolean,"sn":"applySafeAreaToRoots","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"landscapeRoot","t":4,"rt":$n[2].GameObject,"sn":"landscapeRoot"},{"at":[new UnityEngine.HeaderAttribute("Assign two sibling roots")],"a":2,"n":"portraitRoot","t":4,"rt":$n[2].GameObject,"sn":"portraitRoot"}]}; }, $n);
    /*OrientationLayoutSwitcher end.*/

    /*ResponsiveUIManager start.*/
    $m("ResponsiveUIManager", function () { return {"nested":[ResponsiveUIManager.OrientationMode,ResponsiveUIManager.AspectProfile,ResponsiveUIManager.StrictAspectEntry],"att":1048833,"a":2,"at":[new UnityEngine.DisallowMultipleComponent(),new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.Canvas),new UnityEngine.RequireComponent.ctor(UnityEngine.UI.CanvasScaler)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AdjustForOrientation","t":8,"pi":[{"n":"value","pt":$n[0].Single,"ps":0}],"sn":"AdjustForOrientation","rt":$n[0].Single,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ApplyAll","t":8,"pi":[{"n":"force","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"ApplyAll","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"ApplyFrame","t":8,"sn":"ApplyFrame","rt":$n[0].Void},{"a":1,"n":"ApplyOrientation","t":8,"pi":[{"n":"o","pt":$n[2].ScreenOrientation,"ps":0},{"n":"force","pt":$n[0].Boolean,"ps":1}],"sn":"ApplyOrientation","rt":$n[0].Void,"p":[$n[2].ScreenOrientation,$n[0].Boolean]},{"a":1,"n":"ApplySafeArea","t":8,"sn":"ApplySafeArea","rt":$n[0].Void},{"a":1,"n":"ApplyStrictAspect","t":8,"sn":"ApplyStrictAspect","rt":$n[0].Void},{"a":1,"n":"ChooseMatchByAspect","t":8,"pi":[{"n":"width","pt":$n[0].Single,"ps":0},{"n":"height","pt":$n[0].Single,"ps":1},{"n":"fallback","pt":$n[0].Single,"ps":2}],"sn":"ChooseMatchByAspect","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"ClearAspectProfileOverride","t":8,"sn":"ClearAspectProfileOverride","rt":$n[0].Void},{"a":1,"n":"DetectOrientation","t":8,"sn":"DetectOrientation","rt":$n[2].ScreenOrientation,"box":function ($v) { return Bridge.box($v, UnityEngine.ScreenOrientation, System.Enum.toStringFn(UnityEngine.ScreenOrientation));}},{"a":2,"n":"ForceAspectProfile","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"ForceAspectProfile","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"StripDecorativeRaycasts","t":8,"sn":"StripDecorativeRaycasts","rt":$n[0].Void},{"a":1,"n":"TryCache","t":8,"sn":"TryCache","rt":$n[0].Void},{"a":1,"n":"TrySetDynamicPixelsPerUnit","t":8,"pi":[{"n":"scaler","pt":$n[6].CanvasScaler,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"TrySetDynamicPixelsPerUnit","rt":$n[0].Boolean,"p":[$n[6].CanvasScaler,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"_cachedDeviceDpi","t":4,"rt":$n[0].Single,"sn":"_cachedDeviceDpi","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_canvas","t":4,"rt":$n[2].Canvas,"sn":"_canvas"},{"a":1,"n":"_lastDpi","t":4,"rt":$n[0].Single,"sn":"_lastDpi","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_lastDpp","t":4,"rt":$n[0].Single,"sn":"_lastDpp","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_lastMatch","t":4,"rt":$n[0].Single,"sn":"_lastMatch","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_lastOrientation","t":4,"rt":$n[2].ScreenOrientation,"sn":"_lastOrientation","box":function ($v) { return Bridge.box($v, UnityEngine.ScreenOrientation, System.Enum.toStringFn(UnityEngine.ScreenOrientation));}},{"a":1,"n":"_lastSafe","t":4,"rt":$n[2].Rect,"sn":"_lastSafe"},{"a":1,"n":"_lastScreen","t":4,"rt":$n[2].Vector2,"sn":"_lastScreen"},{"a":1,"n":"_scaler","t":4,"rt":$n[6].CanvasScaler,"sn":"_scaler"},{"at":[new UnityEngine.HeaderAttribute("Runtime (read-only)"),new UnityEngine.TooltipAttribute("The index of the currently applied aspect profile. -1 if none.")],"a":2,"n":"activeAspectProfileIndex","t":4,"rt":$n[0].Int32,"sn":"activeAspectProfileIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.TooltipAttribute("The label of the currently applied aspect profile.")],"a":2,"n":"activeAspectProfileLabel","t":4,"rt":$n[0].String,"sn":"activeAspectProfileLabel"},{"at":[new UnityEngine.HeaderAttribute("Aspect Profiles (Match width/height by aspect)")],"a":2,"n":"aspectProfiles","t":4,"rt":System.Array.type(ResponsiveUIManager.AspectProfile),"sn":"aspectProfiles"},{"a":2,"n":"debugTextShadow","t":4,"rt":$n[2].Color,"sn":"debugTextShadow"},{"at":[new UnityEngine.RangeAttribute(8.0, 24.0)],"a":2,"n":"debugTextSize","t":4,"rt":$n[0].Int32,"sn":"debugTextSize","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"defaultMatchWidthOrHeight","t":4,"rt":$n[0].Single,"sn":"defaultMatchWidthOrHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Raycast Hygiene")],"a":2,"n":"disableDecorativeRaycasts","t":4,"rt":$n[0].Boolean,"sn":"disableDecorativeRaycasts","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"dpiClampMax","t":4,"rt":$n[0].Single,"sn":"dpiClampMax","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"dpiClampThreshold","t":4,"rt":$n[0].Single,"sn":"dpiClampThreshold","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("DPI Clamp (legibility)")],"a":2,"n":"enableDpiClamp","t":4,"rt":$n[0].Boolean,"sn":"enableDpiClamp","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Orientation")],"a":2,"n":"forceOrientation","t":4,"rt":ResponsiveUIManager.OrientationMode,"sn":"forceOrientation","box":function ($v) { return Bridge.box($v, ResponsiveUIManager.OrientationMode, System.Enum.toStringFn(ResponsiveUIManager.OrientationMode));}},{"a":2,"n":"landscapeReferenceResolution","t":4,"rt":$n[2].Vector2,"sn":"landscapeReferenceResolution"},{"at":[new UnityEngine.HeaderAttribute("Canvas Scaler (auto-managed)")],"a":2,"n":"manageCanvasScaler","t":4,"rt":$n[0].Boolean,"sn":"manageCanvasScaler","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Aspect Profile Override"),new UnityEngine.TooltipAttribute("If ON, forces the selected AspectProfileIndex below instead of auto-picking by aspect.")],"a":2,"n":"overrideAspectProfile","t":4,"rt":$n[0].Boolean,"sn":"overrideAspectProfile","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Index into AspectProfiles to use when Override is ON.")],"a":2,"n":"overrideAspectProfileIndex","t":4,"rt":$n[0].Int32,"sn":"overrideAspectProfileIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"portraitReferenceResolution","t":4,"rt":$n[2].Vector2,"sn":"portraitReferenceResolution"},{"at":[new UnityEngine.TooltipAttribute("Default reference Resolution if you don\u2019t want orientation-specific ones.")],"a":2,"n":"referenceResolution","t":4,"rt":$n[2].Vector2,"sn":"referenceResolution"},{"at":[new UnityEngine.HeaderAttribute("Safe Area")],"a":2,"n":"safeAreaPanels","t":4,"rt":System.Array.type(UnityEngine.RectTransform),"sn":"safeAreaPanels"},{"at":[new UnityEngine.HeaderAttribute("Debug")],"a":2,"n":"showDebugOverlay","t":4,"rt":$n[0].Boolean,"sn":"showDebugOverlay","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Strict Aspect (optional)")],"a":2,"n":"strictAspectPanels","t":4,"rt":System.Array.type(ResponsiveUIManager.StrictAspectEntry),"sn":"strictAspectPanels"},{"at":[new UnityEngine.HeaderAttribute("Aspect Handling"),new UnityEngine.TooltipAttribute("If ON, uses normalized aspect = max(width,height)/min(width,height) so profiles work in both portrait and landscape. If OFF, uses width/height (portrait < 1, landscape > 1).")],"a":2,"n":"useOrientationAgnosticAspect","t":4,"rt":$n[0].Boolean,"sn":"useOrientationAgnosticAspect","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnOrientationChanged","is":true,"t":2,"ad":{"a":2,"n":"add_OnOrientationChanged","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnOrientationChanged","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnOrientationChanged","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnOrientationChanged","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*ResponsiveUIManager end.*/

    /*ResponsiveUIManager+OrientationMode start.*/
    $m("ResponsiveUIManager.OrientationMode", function () { return {"td":ResponsiveUIManager,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Auto","is":true,"t":4,"rt":ResponsiveUIManager.OrientationMode,"sn":"Auto","box":function ($v) { return Bridge.box($v, ResponsiveUIManager.OrientationMode, System.Enum.toStringFn(ResponsiveUIManager.OrientationMode));}},{"a":2,"n":"Landscape","is":true,"t":4,"rt":ResponsiveUIManager.OrientationMode,"sn":"Landscape","box":function ($v) { return Bridge.box($v, ResponsiveUIManager.OrientationMode, System.Enum.toStringFn(ResponsiveUIManager.OrientationMode));}},{"a":2,"n":"Portrait","is":true,"t":4,"rt":ResponsiveUIManager.OrientationMode,"sn":"Portrait","box":function ($v) { return Bridge.box($v, ResponsiveUIManager.OrientationMode, System.Enum.toStringFn(ResponsiveUIManager.OrientationMode));}}]}; }, $n);
    /*ResponsiveUIManager+OrientationMode end.*/

    /*ResponsiveUIManager+AspectProfile start.*/
    $m("ResponsiveUIManager.AspectProfile", function () { return {"td":ResponsiveUIManager,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"label","t":4,"rt":$n[0].String,"sn":"label"},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"matchWidthOrHeight","t":4,"rt":$n[0].Single,"sn":"matchWidthOrHeight","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"maxAspect","t":4,"rt":$n[0].Single,"sn":"maxAspect","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*ResponsiveUIManager+AspectProfile end.*/

    /*ResponsiveUIManager+StrictAspectEntry start.*/
    $m("ResponsiveUIManager.StrictAspectEntry", function () { return {"td":ResponsiveUIManager,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.TooltipAttribute("Optional Image used as background bars (enable when clamped).")],"a":2,"n":"backgroundBars","t":4,"rt":$n[6].Image,"sn":"backgroundBars"},{"a":2,"n":"panel","t":4,"rt":$n[2].RectTransform,"sn":"panel"},{"at":[new UnityEngine.TooltipAttribute("Target aspect ratio (width/height). If <= 0, uses referenceResolution aspect.")],"a":2,"n":"targetAspect","t":4,"rt":$n[0].Single,"sn":"targetAspect","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*ResponsiveUIManager+StrictAspectEntry end.*/

    /*StartClickHandler start.*/
    $m("StartClickHandler", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EnableSound","t":8,"sn":"EnableSound","rt":$n[0].Void},{"a":2,"n":"OnPointerDown","t":8,"pi":[{"n":"eventData","pt":$n[5].PointerEventData,"ps":0}],"sn":"OnPointerDown","rt":$n[0].Void,"p":[$n[5].PointerEventData]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void}]}; }, $n);
    /*StartClickHandler end.*/

    /*TaskManager start.*/
    $m("TaskManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"CreatePooledSequence","t":8,"sn":"CreatePooledSequence","rt":TaskSequencePro},{"a":2,"n":"CreateSequence","t":8,"sn":"CreateSequence","rt":TaskSequencePro},{"a":1,"n":"DelayRoutine","t":8,"pi":[{"n":"delay","pt":$n[0].Single,"ps":0},{"n":"action","pt":Function,"ps":1}],"sn":"DelayRoutine","rt":$n[3].IEnumerator,"p":[$n[0].Single,Function]},{"a":1,"n":"RepeatingRoutine","t":8,"pi":[{"n":"interval","pt":$n[0].Single,"ps":0},{"n":"action","pt":Function,"ps":1}],"sn":"RepeatingRoutine","rt":$n[3].IEnumerator,"p":[$n[0].Single,Function]},{"a":2,"n":"Run","t":8,"pi":[{"n":"routine","pt":$n[3].IEnumerator,"ps":0}],"sn":"Run","rt":$n[0].Void,"p":[$n[3].IEnumerator]},{"a":2,"n":"RunAfter","t":8,"pi":[{"n":"delay","pt":$n[0].Single,"ps":0},{"n":"action","pt":Function,"ps":1}],"sn":"RunAfter","rt":$n[0].Void,"p":[$n[0].Single,Function]},{"a":2,"n":"RunAfter","t":8,"pi":[{"n":"delay","pt":$n[0].Single,"ps":0},{"n":"func","pt":Function,"ps":1},{"n":"onComplete","pt":Function,"ps":2}],"tpc":1,"tprm":["T"],"sn":"RunAfter$1","rt":$n[0].Void,"p":[$n[0].Single,Function,Function]},{"a":1,"n":"RunAfterRoutine","t":8,"pi":[{"n":"delay","pt":$n[0].Single,"ps":0},{"n":"func","pt":Function,"ps":1},{"n":"onComplete","pt":Function,"ps":2}],"tpc":1,"tprm":["T"],"sn":"RunAfterRoutine","rt":$n[3].IEnumerator,"p":[$n[0].Single,Function,Function]},{"a":2,"n":"RunRepeating","t":8,"pi":[{"n":"interval","pt":$n[0].Single,"ps":0},{"n":"action","pt":Function,"ps":1},{"n":"taskId","dv":null,"o":true,"pt":$n[0].String,"ps":2}],"sn":"RunRepeating","rt":$n[0].Void,"p":[$n[0].Single,Function,$n[0].String]},{"a":2,"n":"RunTask","t":8,"pi":[{"n":"id","pt":$n[0].String,"ps":0},{"n":"routine","pt":$n[3].IEnumerator,"ps":1}],"sn":"RunTask","rt":$n[0].Void,"p":[$n[0].String,$n[3].IEnumerator]},{"a":2,"n":"RunUntil","t":8,"pi":[{"n":"condition","pt":Function,"ps":0},{"n":"onComplete","pt":Function,"ps":1}],"sn":"RunUntil","rt":$n[0].Void,"p":[Function,Function]},{"a":2,"n":"RunWhile","t":8,"pi":[{"n":"condition","pt":Function,"ps":0},{"n":"interval","pt":$n[0].Single,"ps":1},{"n":"onTick","pt":Function,"ps":2},{"n":"onComplete","dv":null,"o":true,"pt":Function,"ps":3}],"sn":"RunWhile","rt":$n[0].Void,"p":[Function,$n[0].Single,Function,Function]},{"a":2,"n":"StopAllTasks","t":8,"sn":"StopAllTasks","rt":$n[0].Void},{"a":2,"n":"StopTask","t":8,"pi":[{"n":"id","pt":$n[0].String,"ps":0}],"sn":"StopTask","rt":$n[0].Void,"p":[$n[0].String]},{"a":1,"n":"WaitUntilRoutine","t":8,"pi":[{"n":"condition","pt":Function,"ps":0},{"n":"onComplete","pt":Function,"ps":1}],"sn":"WaitUntilRoutine","rt":$n[3].IEnumerator,"p":[Function,Function]},{"a":1,"n":"WhileRoutine","t":8,"pi":[{"n":"condition","pt":Function,"ps":0},{"n":"interval","pt":$n[0].Single,"ps":1},{"n":"onTick","pt":Function,"ps":2},{"n":"onComplete","pt":Function,"ps":3}],"sn":"WhileRoutine","rt":$n[3].IEnumerator,"p":[Function,$n[0].Single,Function,Function]},{"a":2,"n":"Instance","is":true,"t":16,"rt":TaskManager,"g":{"a":2,"n":"get_Instance","t":8,"rt":TaskManager,"fg":"Instance","is":true},"s":{"a":1,"n":"set_Instance","t":8,"p":[TaskManager],"rt":$n[0].Void,"fs":"Instance","is":true},"fn":"Instance"},{"a":1,"n":"_taskMap","t":4,"rt":$n[1].Dictionary$2(System.String,UnityEngine.Coroutine),"sn":"_taskMap","ro":true},{"a":1,"backing":true,"n":"<Instance>k__BackingField","is":true,"t":4,"rt":TaskManager,"sn":"Instance"}]}; }, $n);
    /*TaskManager end.*/

    /*TaskSequencePool start.*/
    $m("TaskSequencePool", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Get","t":8,"sn":"Get","rt":TaskSequencePro},{"a":2,"n":"Return","t":8,"pi":[{"n":"sequence","pt":TaskSequencePro,"ps":0}],"sn":"Return","rt":$n[0].Void,"p":[TaskSequencePro]},{"a":2,"n":"Shared","is":true,"t":4,"rt":TaskSequencePool,"sn":"Shared","ro":true},{"a":1,"n":"_manager","t":4,"rt":TaskManager,"sn":"_manager","ro":true},{"a":1,"n":"_pool","t":4,"rt":$n[1].Stack$1(TaskSequencePro),"sn":"_pool","ro":true}]}; }, $n);
    /*TaskSequencePool end.*/

    /*TaskSequencePro start.*/
    $m("TaskSequencePro", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[TaskManager],"pi":[{"n":"manager","pt":TaskManager,"ps":0}],"sn":"ctor"},{"a":1,"n":"ActionRoutine","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"ActionRoutine","rt":$n[3].IEnumerator,"p":[Function]},{"a":2,"n":"Append","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"Append","rt":TaskSequencePro,"p":[Function]},{"a":2,"n":"AppendCallback","t":8,"pi":[{"n":"callback","pt":Function,"ps":0}],"sn":"AppendCallback","rt":TaskSequencePro,"p":[Function]},{"a":2,"n":"AppendCondition","t":8,"pi":[{"n":"conditionRoutine","pt":Function,"ps":0}],"sn":"AppendCondition","rt":TaskSequencePro,"p":[Function]},{"a":2,"n":"AppendDelay","t":8,"pi":[{"n":"delay","pt":$n[0].Single,"ps":0}],"sn":"AppendDelay","rt":TaskSequencePro,"p":[$n[0].Single]},{"a":2,"n":"AppendDelayIf","t":8,"pi":[{"n":"condition","pt":$n[0].Boolean,"ps":0},{"n":"delay","pt":$n[0].Single,"ps":1}],"sn":"AppendDelayIf","rt":TaskSequencePro,"p":[$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AppendDelayRealtime","t":8,"pi":[{"n":"delay","pt":$n[0].Single,"ps":0}],"sn":"AppendDelayRealtime","rt":TaskSequencePro,"p":[$n[0].Single]},{"a":2,"n":"AppendIf","t":8,"pi":[{"n":"condition","pt":$n[0].Boolean,"ps":0},{"n":"action","pt":Function,"ps":1}],"sn":"AppendIf","rt":TaskSequencePro,"p":[$n[0].Boolean,Function]},{"a":2,"n":"AppendParallel","t":8,"pi":[{"n":"actions","ip":true,"pt":$n[0].Array.type(Function),"ps":0}],"sn":"AppendParallel","rt":TaskSequencePro,"p":[$n[0].Array.type(Function)]},{"a":2,"n":"AppendParallel","t":8,"pi":[{"n":"routines","ip":true,"pt":System.Array.type(System.Collections.IEnumerator),"ps":0}],"sn":"AppendParallel$1","rt":TaskSequencePro,"p":[System.Array.type(System.Collections.IEnumerator)]},{"a":2,"n":"AppendParallelTweens","t":8,"pi":[{"n":"tweens","ip":true,"pt":System.Array.type(DG.Tweening.Tween),"ps":0}],"sn":"AppendParallelTweens","rt":TaskSequencePro,"p":[System.Array.type(DG.Tweening.Tween)]},{"a":2,"n":"AppendRepeat","t":8,"pi":[{"n":"count","pt":$n[0].Int32,"ps":0},{"n":"action","pt":Function,"ps":1},{"n":"interval","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"AppendRepeat","rt":TaskSequencePro,"p":[$n[0].Int32,Function,$n[0].Single]},{"a":2,"n":"AppendRoutine","t":8,"pi":[{"n":"routine","pt":$n[3].IEnumerator,"ps":0}],"sn":"AppendRoutine","rt":TaskSequencePro,"p":[$n[3].IEnumerator]},{"a":2,"n":"AppendTween","t":8,"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"AppendTween","rt":TaskSequencePro,"p":[$n[4].Tween]},{"a":2,"n":"AppendTweenIf","t":8,"pi":[{"n":"condition","pt":$n[0].Boolean,"ps":0},{"n":"tween","pt":$n[4].Tween,"ps":1}],"sn":"AppendTweenIf","rt":TaskSequencePro,"p":[$n[0].Boolean,$n[4].Tween]},{"a":2,"n":"AppendWaitForEndOfFrame","t":8,"sn":"AppendWaitForEndOfFrame","rt":TaskSequencePro},{"a":2,"n":"AppendWaitForFixedUpdate","t":8,"sn":"AppendWaitForFixedUpdate","rt":TaskSequencePro},{"a":2,"n":"AppendWaitUntil","t":8,"pi":[{"n":"condition","pt":Function,"ps":0}],"sn":"AppendWaitUntil","rt":TaskSequencePro,"p":[Function]},{"a":2,"n":"AppendWaitWhile","t":8,"pi":[{"n":"condition","pt":Function,"ps":0}],"sn":"AppendWaitWhile","rt":TaskSequencePro,"p":[Function]},{"a":2,"n":"Cancel","t":8,"sn":"Cancel","rt":$n[0].Void},{"a":1,"n":"DelayRealtimeRoutine","t":8,"pi":[{"n":"delay","pt":$n[0].Single,"ps":0}],"sn":"DelayRealtimeRoutine","rt":$n[3].IEnumerator,"p":[$n[0].Single]},{"a":1,"n":"DelayRoutine","t":8,"pi":[{"n":"delay","pt":$n[0].Single,"ps":0}],"sn":"DelayRoutine","rt":$n[3].IEnumerator,"p":[$n[0].Single]},{"a":1,"n":"HandleComplete","t":8,"sn":"HandleComplete","rt":$n[0].Void},{"a":2,"n":"OnCancel","t":8,"pi":[{"n":"callback","pt":Function,"ps":0}],"sn":"OnCancel","rt":TaskSequencePro,"p":[Function]},{"a":2,"n":"OnComplete","t":8,"pi":[{"n":"callback","pt":Function,"ps":0}],"sn":"OnComplete","rt":TaskSequencePro,"p":[Function]},{"a":2,"n":"Pause","t":8,"sn":"Pause","rt":$n[0].Void},{"a":1,"n":"RepeatRoutine","t":8,"pi":[{"n":"count","pt":$n[0].Int32,"ps":0},{"n":"action","pt":Function,"ps":1},{"n":"interval","pt":$n[0].Single,"ps":2}],"sn":"RepeatRoutine","rt":$n[3].IEnumerator,"p":[$n[0].Int32,Function,$n[0].Single]},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":TaskSequencePro},{"a":2,"n":"Restart","t":8,"sn":"Restart","rt":TaskSequencePro},{"a":2,"n":"Resume","t":8,"sn":"Resume","rt":$n[0].Void},{"a":1,"n":"ReturnToPoolIfNeeded","t":8,"sn":"ReturnToPoolIfNeeded","rt":$n[0].Void},{"a":1,"n":"RunAndTrack","t":8,"pi":[{"n":"routine","pt":$n[3].IEnumerator,"ps":0},{"n":"onComplete","pt":Function,"ps":1}],"sn":"RunAndTrack","rt":$n[3].IEnumerator,"p":[$n[3].IEnumerator,Function]},{"a":1,"n":"RunParallelRoutines","t":8,"pi":[{"n":"routines","pt":System.Array.type(System.Collections.IEnumerator),"ps":0}],"sn":"RunParallelRoutines","rt":$n[3].IEnumerator,"p":[System.Array.type(System.Collections.IEnumerator)]},{"a":1,"n":"RunSequence","t":8,"sn":"RunSequence","rt":$n[3].IEnumerator},{"a":2,"n":"Start","t":8,"sn":"Start","rt":TaskSequencePro},{"a":1,"n":"WaitForEndOfFrameRoutine","t":8,"sn":"WaitForEndOfFrameRoutine","rt":$n[3].IEnumerator},{"a":1,"n":"WaitForFixedUpdateRoutine","t":8,"sn":"WaitForFixedUpdateRoutine","rt":$n[3].IEnumerator},{"a":1,"n":"WaitForTween","t":8,"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"WaitForTween","rt":$n[3].IEnumerator,"p":[$n[4].Tween]},{"a":1,"n":"WaitUntilRoutine","t":8,"pi":[{"n":"condition","pt":Function,"ps":0}],"sn":"WaitUntilRoutine","rt":$n[3].IEnumerator,"p":[Function]},{"a":1,"n":"WaitWhileRoutine","t":8,"pi":[{"n":"condition","pt":Function,"ps":0}],"sn":"WaitWhileRoutine","rt":$n[3].IEnumerator,"p":[Function]},{"a":1,"n":"CoroutineHost","t":16,"rt":$n[2].MonoBehaviour,"g":{"a":1,"n":"get_CoroutineHost","t":8,"rt":$n[2].MonoBehaviour,"fg":"CoroutineHost"},"fn":"CoroutineHost"},{"a":2,"n":"HasStarted","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_HasStarted","t":8,"rt":$n[0].Boolean,"fg":"HasStarted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"HasStarted"},{"a":2,"n":"IsCancelled","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsCancelled","t":8,"rt":$n[0].Boolean,"fg":"IsCancelled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsCancelled"},{"a":2,"n":"IsCompleted","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsCompleted","t":8,"rt":$n[0].Boolean,"fg":"IsCompleted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsCompleted"},{"a":2,"n":"IsPaused","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsPaused","t":8,"rt":$n[0].Boolean,"fg":"IsPaused","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsPaused"},{"a":2,"n":"IsRunning","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsRunning","t":8,"rt":$n[0].Boolean,"fg":"IsRunning","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsRunning"},{"a":4,"n":"Pool","t":16,"rt":TaskSequencePool,"g":{"a":4,"n":"get_Pool","t":8,"rt":TaskSequencePool,"fg":"Pool"},"s":{"a":4,"n":"set_Pool","t":8,"p":[TaskSequencePool],"rt":$n[0].Void,"fs":"Pool"},"fn":"Pool"},{"a":1,"n":"_currentRoutine","t":4,"rt":$n[2].Coroutine,"sn":"_currentRoutine"},{"a":1,"n":"_hasStarted","t":4,"rt":$n[0].Boolean,"sn":"_hasStarted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_isCancelled","t":4,"rt":$n[0].Boolean,"sn":"_isCancelled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_isCompleted","t":4,"rt":$n[0].Boolean,"sn":"_isCompleted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_isPaused","t":4,"rt":$n[0].Boolean,"sn":"_isPaused","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_isRunning","t":4,"rt":$n[0].Boolean,"sn":"_isRunning","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_manager","t":4,"rt":TaskManager,"sn":"_manager","ro":true},{"a":1,"n":"_onCancel","t":4,"rt":Function,"sn":"_onCancel"},{"a":1,"n":"_onComplete","t":4,"rt":Function,"sn":"_onComplete"},{"a":1,"n":"_steps","t":4,"rt":$n[1].Queue$1(System.Collections.IEnumerator),"sn":"_steps","ro":true},{"a":1,"backing":true,"n":"<Pool>k__BackingField","t":4,"rt":TaskSequencePool,"sn":"Pool"}]}; }, $n);
    /*TaskSequencePro end.*/

    /*UIDragger start.*/
    $m("UIDragger", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"OnBeginDrag","t":8,"pi":[{"n":"e","pt":$n[5].PointerEventData,"ps":0}],"sn":"OnBeginDrag","rt":$n[0].Void,"p":[$n[5].PointerEventData]},{"a":2,"n":"OnDrag","t":8,"pi":[{"n":"e","pt":$n[5].PointerEventData,"ps":0}],"sn":"OnDrag","rt":$n[0].Void,"p":[$n[5].PointerEventData]},{"a":2,"n":"OnEndDrag","t":8,"pi":[{"n":"e","pt":$n[5].PointerEventData,"ps":0}],"sn":"OnEndDrag","rt":$n[0].Void,"p":[$n[5].PointerEventData]},{"a":1,"n":"canvas","t":4,"rt":$n[2].Canvas,"sn":"canvas"},{"a":1,"n":"rt","t":4,"rt":$n[2].RectTransform,"sn":"rt"},{"a":1,"n":"startPos","t":4,"rt":$n[2].Vector2,"sn":"startPos"}]}; }, $n);
    /*UIDragger end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*Core.Services.IAudioService start.*/
    $m("Core.Services.IAudioService", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"PlayMusic","t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"fadeDuration","dv":1.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"Core$Services$IAudioService$PlayMusic","rt":$n[0].Void,"p":[$n[0].String,$n[0].Single]},{"ab":true,"a":2,"n":"PlaySFX","t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"position","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Vector3),"ps":1},{"n":"pitch","dv":1.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"Core$Services$IAudioService$PlaySFX","rt":$n[0].Void,"p":[$n[0].String,$n[0].Nullable$1(UnityEngine.Vector3),$n[0].Single]},{"ab":true,"a":2,"n":"SetMusicVolume","t":8,"pi":[{"n":"volume","pt":$n[0].Single,"ps":0}],"sn":"Core$Services$IAudioService$SetMusicVolume","rt":$n[0].Void,"p":[$n[0].Single]},{"ab":true,"a":2,"n":"SetSFXVolume","t":8,"pi":[{"n":"volume","pt":$n[0].Single,"ps":0}],"sn":"Core$Services$IAudioService$SetSFXVolume","rt":$n[0].Void,"p":[$n[0].Single]},{"ab":true,"a":2,"n":"StopMusic","t":8,"pi":[{"n":"fadeDuration","dv":1.0,"o":true,"pt":$n[0].Single,"ps":0}],"sn":"Core$Services$IAudioService$StopMusic","rt":$n[0].Void,"p":[$n[0].Single]}]}; }, $n);
    /*Core.Services.IAudioService end.*/

    /*Core.Services.ServicesLocator start.*/
    $m("Core.Services.ServicesLocator", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ClearAll","is":true,"t":8,"sn":"ClearAll","rt":$n[0].Void},{"a":2,"n":"Get","is":true,"t":8,"tpc":1,"tprm":["T"],"sn":"Get","rt":System.Object},{"a":2,"n":"Register","is":true,"t":8,"pi":[{"n":"service","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"Register","rt":$n[0].Void,"p":[System.Object]},{"a":2,"n":"Unregister","is":true,"t":8,"tpc":1,"tprm":["T"],"sn":"Unregister","rt":$n[0].Void},{"a":1,"n":"_services","is":true,"t":4,"rt":$n[1].Dictionary$2(System.Type,System.Object),"sn":"_services","ro":true}]}; }, $n);
    /*Core.Services.ServicesLocator end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[4].Tweener,"p":[$n[2].SpriteRenderer,$n[2].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[7].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[2].SpriteRenderer,$n[2].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[7].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[2].SpriteRenderer,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].SpriteRenderer,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[4].Sequence,"p":[$n[2].SpriteRenderer,pc.ColorGradient,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[4].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[7].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[7].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[7].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[7].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Graphic,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[4].Tweener,"p":[$n[6].Graphic,$n[2].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Image,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[4].Tweener,"p":[$n[6].Image,$n[2].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Text,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[4].Tweener,"p":[$n[6].Text,$n[2].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Graphic,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[7].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Graphic,$n[2].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Image,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$1","rt":$n[7].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Image,$n[2].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Outline,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$2","rt":$n[7].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Outline,$n[2].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Text,"ps":0},{"n":"endValue","pt":$n[2].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$3","rt":$n[7].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Text,$n[2].Color,$n[0].Single]},{"a":2,"n":"DOCounter","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Text,"ps":0},{"n":"fromValue","pt":$n[0].Int32,"ps":1},{"n":"endValue","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"addThousandsSeparator","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"culture","dv":null,"o":true,"pt":$n[8].CultureInfo,"ps":5}],"sn":"DOCounter","rt":$n[7].TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions),"p":[$n[6].Text,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[8].CultureInfo]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[7].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[2].CanvasGroup,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Graphic,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$1","rt":$n[7].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Graphic,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$2","rt":$n[7].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Outline,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$3","rt":$n[7].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Outline,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Text,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$4","rt":$n[7].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[6].Text,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[7].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[6].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].LayoutElement,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[6].LayoutElement,$n[2].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Image,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[4].Sequence,"p":[$n[6].Image,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[4].Tweener,"p":[$n[6].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[4].Sequence,"p":[$n[2].RectTransform,$n[2].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].LayoutElement,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[6].LayoutElement,$n[2].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].ScrollRect,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[4].Tweener,"p":[$n[6].ScrollRect,$n[2].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivot","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[0].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotX","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotY","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].LayoutElement,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[6].LayoutElement,$n[2].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"punch","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[4].Tweener,"p":[$n[2].RectTransform,$n[2].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOScale","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Outline,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOScale","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[6].Outline,$n[2].Vector2,$n[0].Single]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[4].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos","rt":$n[4].Tweener,"p":[$n[2].RectTransform,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[4].ShakeRandomnessMode]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","pt":$n[2].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"randomnessMode","dv":0,"o":true,"pt":$n[4].ShakeRandomnessMode,"ps":7}],"sn":"DOShakeAnchorPos$1","rt":$n[4].Tweener,"p":[$n[2].RectTransform,$n[0].Single,$n[2].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean,$n[4].ShakeRandomnessMode]},{"a":2,"n":"DOShapeCircle","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"center","pt":$n[2].Vector2,"ps":1},{"n":"endValueDegrees","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"relativeCenter","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOShapeCircle","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.CircleOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].RectTransform,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].RectTransform,$n[2].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Text,"ps":0},{"n":"endValue","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[4].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[0].String,"ps":5}],"sn":"DOText","rt":$n[7].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[6].Text,$n[0].String,$n[0].Single,$n[0].Boolean,$n[4].ScrambleMode,$n[0].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].Slider,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOValue","rt":$n[7].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[6].Slider,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[6].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[4].Tweener,"p":[$n[6].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[4].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[2].RectTransform,"ps":0},{"n":"to","pt":$n[2].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[2].Vector2,"p":[$n[2].RectTransform,$n[2].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[4].Sequence,"p":[$n[2].Material,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"property","pt":$n[0].String,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[4].Sequence,"p":[$n[2].Material,pc.ColorGradient,$n[0].String,$n[0].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Material,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOOffset","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Material,$n[2].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Material,"ps":0},{"n":"endValue","pt":$n[2].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOTiling","rt":$n[7].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[2].Material,$n[2].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[2].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[2].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[2].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[2].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[2].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[2].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[4].DOTweenCYInstruction.WaitForCompletion,$n[4].DOTweenCYInstruction.WaitForRewind,$n[4].DOTweenCYInstruction.WaitForKill,$n[4].DOTweenCYInstruction.WaitForElapsedLoops,$n[4].DOTweenCYInstruction.WaitForPosition,$n[4].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween,$n[0].Int32],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[0].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween,$n[0].Single],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[4].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[0].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[4].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[0].Boolean,"ps":1},{"n":"isLocal","pt":$n[0].Boolean,"ps":2},{"n":"path","pt":$n[9].Path,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"pathMode","pt":$n[4].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[7].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[2].MonoBehaviour,$n[0].Boolean,$n[0].Boolean,$n[9].Path,$n[0].Single,$n[4].PathMode]},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[0].Boolean,"p":[$n[2].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[2].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[0].Boolean,"p":[$n[2].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[10].PathOptions,"ps":0},{"n":"t","pt":$n[4].Tween,"ps":1},{"n":"newRot","pt":$n[2].Quaternion,"ps":2},{"n":"trans","pt":$n[2].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[0].Void,"p":[$n[10].PathOptions,$n[4].Tween,$n[2].Quaternion,$n[2].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    }});
